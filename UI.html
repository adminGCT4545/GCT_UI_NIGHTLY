<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GCT Enterprise App Concept</title>
    <!-- 1. Link to your actual CSS file -->
    <link rel="stylesheet" href="style.css"> <!-- Example: Link to an external CSS file -->

    <!-- 2. Include Highlight.js CSS (choose a theme) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <!-- Or link your own theme -->

    <style>
        /* Or add basic styles here */
        /* Example: Basic styling for AI highlight */
        .ai-edit-highlight {
            animation: highlight-fade 3s ease-out;
            background-color: rgba(255, 255, 0, 0.3); /* Initial highlight */
        }

        @keyframes highlight-fade {
            from { background-color: rgba(255, 255, 0, 0.5); } /* More prominent start */
            to { background-color: transparent; }
        }

        /* Add other necessary styles from your external file or here */
        :root {
            --border-color: #ccc;
            --text-muted: #666;
            --bg-primary: #fff;
            --accent-primary: #007bff;
            --text-secondary: #333;
            --danger-color: #dc3545;
            /* Define other variables used in inline styles if moving them */
        }
        /* ... (add many more styles needed for layout, buttons, etc.) ... */

        /* Basic placeholder styles if no external CSS is ready */
        body { font-family: sans-serif; margin: 0; display: flex; }
        .sidebar { width: 250px; border-right: 1px solid var(--border-color); padding: 1rem; display: flex; flex-direction: column; height: 100vh; background: #f8f9fa; }
        .sidebar.expanded { width: 250px; } /* Adjust as needed */
        .sidebar:not(.expanded) { width: 60px; }
        .sidebar:not(.expanded) .sidebar-item-text,
        .sidebar:not(.expanded) .sidebar-section-title { display: none; }
        .sidebar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .sidebar-button { background: none; border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; width: 100%; margin-bottom: 0.5rem; text-align: left; }
        .sidebar-button span:first-child { min-width: 20px; text-align: center; }
        .sidebar-item { background: none; border: none; padding: 0.5rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; width: 100%; margin-bottom: 0.2rem; text-align: left; border-radius: 4px; }
        .sidebar-item.active { background-color: #e9ecef; }
        .sidebar-section { margin-top: 1rem; }
        .sidebar-section-title { color: var(--text-muted); font-size: 0.8rem; margin-bottom: 0.5rem; text-transform: uppercase; }
        .badge { background-color: var(--danger-color); color: white; border-radius: 50%; padding: 2px 6px; font-size: 0.7rem; margin-left: 5px; }

        .main-content-wrapper { flex-grow: 1; display: flex; height: 100vh; overflow: hidden; }
        .main-content { flex-grow: 1; display: flex; flex-direction: column; overflow-y: auto; }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 1rem; border-bottom: 1px solid var(--border-color); background: var(--bg-primary); }
        .header-left, .header-right { display: flex; align-items: center; gap: 1rem; }
        .app-title { font-size: 1.2rem; margin: 0; }
        .app-subtitle { font-size: 0.8rem; color: var(--text-muted); margin: 0; }
        #conversationTitle { font-size: 1.1rem; margin: 0; cursor: pointer; }
        #conversationTitleInput { display: none; font-size: 1.1rem; padding: 0.2rem; border: 1px solid var(--border-color); }
        #notification-badge { background-color: var(--danger-color); color: white; border-radius: 50%; padding: 2px 6px; font-size: 0.7rem; margin-left: -5px; display: none; /* Initially hidden */ align-items: center; justify-content: center; min-width: 18px; height: 18px; }


        .chat-container { flex-grow: 1; padding: 1rem; overflow-y: auto; }
        .message { margin-bottom: 1rem; padding: 0.8rem 1rem; border-radius: 8px; max-width: 80%; position: relative; }
        .user-message { background-color: #e7f3ff; align-self: flex-end; margin-left: auto; }
        .assistant-message { background-color: #f1f1f1; align-self: flex-start; margin-right: auto; }
        .message.streaming::after { content: '‚ñç'; animation: blink 1s infinite; margin-left: 5px; }
        @keyframes blink { 50% { opacity: 0; } }
        .delete-message-btn { position: absolute; top: 2px; right: 5px; background: none; border: none; color: #aaa; cursor: pointer; font-size: 1.2rem; display: none; }
        .message:hover .delete-message-btn { display: block; }
        .message-actions { display: none; position: absolute; bottom: -15px; right: 10px; background: white; border: 1px solid #eee; border-radius: 4px; padding: 2px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .message:hover .message-actions { display: flex; gap: 3px; }
        .message-action-btn { background: none; border: none; cursor: pointer; font-size: 0.8rem; padding: 3px; }
        pre { background-color: #eee; padding: 1rem; border-radius: 5px; overflow-x: auto; position: relative; } /* Added position relative */
        code { font-family: monospace; }
        .copy-code-btn { position: absolute; top: 5px; right: 5px; background: #ddd; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 0.8rem; opacity: 0.7; }
        .copy-code-btn:hover { opacity: 1; }
        .copy-code-btn.copied { background-color: #aeffae; }
        .citation { background-color: #d6eaff; padding: 1px 4px; border-radius: 3px; cursor: help; font-size: 0.8em; vertical-align: super; }
        .citation-source-list { font-size: 0.8rem; margin-top: 0.8rem; padding-top: 0.5rem; border-top: 1px dashed #ccc; color: var(--text-muted); }
        .citation-source-list h4 { margin: 0 0 0.3rem 0; font-size: 0.85rem; }
        .citation-source-list ul { margin: 0; padding-left: 1.2rem; }
        .confidence-score { font-size: 0.8rem; color: var(--text-muted); margin-left: 5px; }


        .input-container { padding: 1rem; border-top: 1px solid var(--border-color); background: var(--bg-primary); }
        .input-wrapper { display: flex; align-items: flex-end; border: 1px solid var(--border-color); border-radius: 8px; padding: 0.5rem; position: relative; }
        .input-actions { display: flex; align-items: center; margin-right: 0.5rem; }
        .input-action-button { background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.3rem; color: #555; }
        #fileInput { display: none; }
        .message-input { flex-grow: 1; border: none; outline: none; resize: none; font-size: 1rem; padding: 0.5rem; max-height: 150px; /* Example max height */ overflow-y: auto; }
        .send-button { background-color: var(--accent-primary); color: white; border: none; border-radius: 5px; padding: 0.6rem 1rem; cursor: pointer; margin-left: 0.5rem; }
        .send-button:disabled { background-color: #ccc; cursor: not-allowed; }
        .templates-popup { display: none; position: absolute; bottom: 100%; left: 0; background: white; border: 1px solid #ccc; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); max-height: 200px; overflow-y: auto; z-index: 10; min-width: 200px; }
        .templates-popup.active { display: block; }
        .template-item { padding: 0.5rem 1rem; cursor: pointer; font-size: 0.9rem; }
        .template-item:hover { background-color: #f0f0f0; }
        .template-item strong { display: block; margin-bottom: 0.2rem; }


        .analysis-dashboard { display: none; /* Initially hidden */ flex-wrap: wrap; gap: 1rem; padding: 1rem; }
        .dashboard-section { border: 1px solid var(--border-color); border-radius: 8px; padding: 1rem; flex: 1 1 300px; /* Flex basis */ background: var(--bg-primary); }
        .dashboard-section-title { margin-top: 0; color: var(--text-secondary); }
        #documentViewerPlaceholder, #entityHighlightPlaceholder, #timeSeriesChartPlaceholder, #anomalyVizPlaceholder, #predictiveVizPlaceholder { min-height: 150px; background: #f9f9f9; border: 1px dashed #ddd; display: flex; align-items: center; justify-content: center; color: #999; border-radius: 4px; margin-bottom: 1rem; }
        #annotationToolbar { background: #eee; padding: 5px; border-radius: 4px; margin-bottom: 10px; }
        .tool-btn { background: white; border: 1px solid #ccc; border-radius: 3px; padding: 3px 6px; cursor: pointer; }
        .placeholder-text { color: var(--text-muted); font-style: italic; }


        .right-panel { width: 300px; border-left: 1px solid var(--border-color); padding: 1rem; background: #f8f9fa; height: 100vh; overflow-y: auto; display: none; /* Initially hidden */ }
        .right-panel.visible { display: block; }
        .artifact { border: 1px solid #ddd; border-radius: 5px; margin-bottom: 1rem; background: white; }
        .artifact-header { display: flex; justify-content: space-between; padding: 0.5rem; background: #eee; border-bottom: 1px solid #ddd; font-size: 0.9rem; }
        .artifact-title { font-weight: bold; }
        .artifact-type { background: #ccc; color: #333; padding: 2px 5px; border-radius: 3px; font-size: 0.7rem; }
        .artifact-content { padding: 0.5rem; max-height: 200px; overflow-y: auto; }
        .artifact-content pre { background: #f0f0f0; padding: 0.5rem; }


        .settings-panel { position: fixed; top: 0; right: -450px; /* Start off-screen */ width: 400px; max-width: 90%; height: 100%; background: white; box-shadow: -2px 0 5px rgba(0,0,0,0.1); z-index: 100; transition: right 0.3s ease-in-out; display: flex; flex-direction: column; }
        .settings-panel.active { right: 0; }
        .settings-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem; border-bottom: 1px solid var(--border-color); }
        .settings-title { margin: 0; font-size: 1.2rem; }
        .close-settings { background: none; border: none; font-size: 1.5rem; cursor: pointer; }
        .settings-tabs { display: flex; border-bottom: 1px solid var(--border-color); }
        .settings-tab { flex-grow: 1; padding: 0.8rem 0.5rem; background: none; border: none; border-bottom: 2px solid transparent; cursor: pointer; text-align: center; font-size: 0.9rem; color: var(--text-muted); }
        .settings-tab.active { border-bottom-color: var(--accent-primary); color: var(--accent-primary); font-weight: bold; }
        .settings-content-wrapper { padding: 1rem; overflow-y: auto; flex-grow: 1; }
        .settings-content { display: none; }
        .settings-content.active { display: block; }
        .settings-section { margin-bottom: 1.5rem; }
        .settings-section-title { margin-bottom: 0.8rem; font-size: 1rem; color: var(--text-secondary); border-bottom: 1px solid #eee; padding-bottom: 0.3rem; }
        .settings-button { background-color: #eee; border: 1px solid #ccc; border-radius: 4px; padding: 0.5rem 1rem; cursor: pointer; margin-right: 0.5rem; margin-bottom: 0.5rem; font-size: 0.9rem; }
        .settings-button.primary { background-color: var(--accent-primary); color: white; border-color: var(--accent-primary); }
        .settings-button.danger { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }
        .settings-option { display: flex; align-items: center; margin-bottom: 0.5rem; font-size: 0.9rem; }
        .settings-option input[type="radio"], .settings-option input[type="checkbox"] { margin-right: 0.5rem; }
        .settings-option label { margin-left: 0.2rem; }
        .settings-option select, .settings-option input[type="text"] { padding: 0.4rem; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; }
        .slider-container { display: flex; align-items: center; gap: 1rem; }
        .compliance-logos img { height: 30px; margin-right: 10px; opacity: 0.7; }
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 120px; background-color: black; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -60px; opacity: 0; transition: opacity 0.3s; font-size: 0.8rem; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }


        .file-upload-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; /* Initially hidden */ align-items: center; justify-content: center; z-index: 101; }
        .file-upload-modal.active { display: flex; }
        .modal-content { background: white; padding: 2rem; border-radius: 8px; max-width: 500px; width: 90%; box-shadow: 0 5px 15px rgba(0,0,0,0.2); position: relative; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 1px solid #eee; padding-bottom: 1rem; }
        .modal-title { margin: 0; font-size: 1.3rem; }
        .close-modal { background: none; border: none; font-size: 1.8rem; cursor: pointer; line-height: 1; }
        .file-upload-area { border: 2px dashed #ccc; border-radius: 8px; padding: 2rem; text-align: center; margin-bottom: 1.5rem; cursor: pointer; }
        .file-upload-area.dragover { border-color: var(--accent-primary); background-color: #f0f7ff; }
        .file-upload-text { color: var(--text-muted); margin: 0; }
        .file-preview { max-width: 100%; max-height: 150px; margin-top: 1rem; border-radius: 4px; display: none; /* Initially hidden */ }
        .file-info { margin-top: 1rem; display: none; /* Initially hidden */ align-items: center; justify-content: center; gap: 0.5rem; }
        .upload-options { margin-bottom: 1.5rem; }
        .upload-options h4 { margin-top: 0; margin-bottom: 0.8rem; font-size: 1rem; }
        .file-upload-buttons { display: flex; justify-content: flex-end; gap: 1rem; }
        .cancel-button, .upload-button { padding: 0.6rem 1.2rem; border-radius: 5px; cursor: pointer; font-size: 0.9rem; }
        .cancel-button { background: #eee; border: 1px solid #ccc; }
        .upload-button { background: var(--accent-primary); color: white; border: 1px solid var(--accent-primary); }
        .upload-button:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; }


        .batch-processing-panel { position: fixed; bottom: 0; right: -450px; /* Start off-screen */ width: 400px; max-width: 90%; height: 40vh; background: white; box-shadow: 0 -2px 5px rgba(0,0,0,0.1); z-index: 90; transition: right 0.3s ease-in-out; display: flex; flex-direction: column; border-top: 1px solid var(--border-color); }
        .batch-processing-panel.visible { right: 0; }
        .batch-panel-header { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1rem; border-bottom: 1px solid var(--border-color); background: #f8f9fa; }
        .batch-panel-title { margin: 0; font-size: 1rem; }
        .batch-panel-actions button { margin-left: 0.5rem; }
        .batch-queue-list { padding: 1rem; overflow-y: auto; flex-grow: 1; }
        .batch-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid #eee; font-size: 0.9rem; }
        .batch-item:last-child { border-bottom: none; }
        .batch-item-name { flex-grow: 1; margin-right: 1rem; }
        .batch-item-status { font-weight: bold; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; }
        .batch-item-status.processing { color: #007bff; background: #e7f3ff; }
        .batch-item-status.completed { color: #28a745; background: #eaf7ec; }
        .batch-item-status.failed { color: #dc3545; background: #fbebec; }
        .batch-item-progress { width: 100px; height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden; margin-left: 5px; }
        .batch-item-progress-bar { height: 100%; background: var(--accent-primary); }


        .notepad-container { position: fixed; bottom: 60px; /* Adjust based on input container height */ right: 20px; width: 300px; max-width: 80%; background: #fffff0; /* Light yellow */ border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.15); z-index: 95; display: none; /* Initially hidden */ flex-direction: column; max-height: 50vh; }
        .notepad-container.visible { display: flex; }
        .notepad-header { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.8rem; border-bottom: 1px solid #eee; background: #f8f8e8; }
        .notepad-title { margin: 0; font-size: 1rem; }
        .notepad-actions button { background: none; border: none; cursor: pointer; font-size: 1rem; color: #666; padding: 0.2rem; }
        .notepad-content { flex-grow: 1; padding: 0.8rem; overflow-y: auto; font-size: 0.9rem; line-height: 1.4; min-height: 100px; outline: none; }
        .notepad-content[contenteditable=true]:empty:before { content: attr(data-placeholder); color: #999; font-style: italic; }
        .notepad-footer { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.8rem; border-top: 1px solid #eee; background: #f8f8e8; font-size: 0.8rem; }
        .notepad-status { color: #777; opacity: 0.7; transition: opacity 0.5s; }
        .notepad-buttons button { background: #eee; border: 1px solid #ccc; border-radius: 4px; padding: 0.3rem 0.6rem; cursor: pointer; font-size: 0.8rem; margin-left: 0.5rem; }

    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <!-- ... (sidebar content remains the same) ... -->
         <div class="sidebar-header">
             <button class="sidebar-button" id="newChatBtn" title="New Chat"><span>+</span> <span class="sidebar-item-text">New Chat</span></button>
             <button class="sidebar-button" id="collapseToggleBtn" title="Collapse Menu"><span>&lt;</span></button>
        </div>
        <div id="conversationList"></div>
        <div class="sidebar-section">
            <div class="sidebar-section-title">Workflows</div>
            <button class="sidebar-button" id="approvalQueueBtn" title="Approval Queue"><span>&#128204;</span> <span class="sidebar-item-text">Approvals <span class="badge">3</span></span></button>
             <button class="sidebar-button" id="batchProcessingToggleBtn" title="Batch Processing"><span>&#128230;</span> <span class="sidebar-item-text">Batch Jobs</span></button>
        </div>
         <div class="sidebar-section">
             <div class="sidebar-section-title">Knowledge</div>
             <button class="sidebar-button" id="docLibraryBtn" title="Document Library"><span>&#128193;</span> <span class="sidebar-item-text">Doc Library</span></button>
         </div>
        <div style="margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--border-color); width: 100%;">
             <button class="sidebar-button" id="settingsBtn" title="Settings"><span>&#9881;</span> <span class="sidebar-item-text">Settings</span></button>
        </div>
    </div>

    <!-- Main Content Wrapper -->
    <div class="main-content-wrapper">
        <div class="main-content" id="mainContent">
            <!-- Header -->
            <header class="header">
                <!-- ... (header content remains the same) ... -->
                 <div class="header-left">
                    <div class="app-info">
                        <h1 class="app-title">GCT Enterprise App Concept</h1>
                        <p class="app-subtitle">Enterprise Analysis Platform</p>
                    </div>
                    <h2 id="conversationTitle" title="Click to rename">Analysis Session</h2>
                    <input type="text" id="conversationTitleInput" placeholder="Enter new title..." />
                </div>
                <div class="header-right">
                    <button id="viewModeToggle" title="Toggle Dashboard View">Dashboard View</button>
                    <button id="notificationsBtn" title="Notifications">
                        <span>&#128276;</span>
                        <!-- Ensure this ID matches the JS -->
                        <span id="notification-badge">0</span>
                    </button>
                    <div id="userProfilePlaceholder"></div>
                </div>
            </header>

            <!-- Chat Container -->
            <main class="chat-container" id="chatContainer"></main>

            <!-- Input Container -->
            <div class="input-container" id="inputContainer">
                 <!-- ... (input container content remains the same) ... -->
                 <div class="input-wrapper">
                    <div class="templates-popup" id="templatesPopup"></div>
                    <form class="input-form" id="chatForm">
                        <div class="input-actions">
                            <button type="button" class="input-action-button" id="templateBtn" title="Prompt Templates"><span>&#128220;</span></button>
                            <button type="button" class="input-action-button" id="uploadFileBtn" title="Upload File"><span>&#128206;</span></button>
                            <!-- Notepad Toggle Button -->
                            <button type="button" class="input-action-button" id="notepadToggleBtn" title="Toggle Notepad"><span>&#128221;</span></button>
                            <input type="file" id="fileInput" accept="image/*,application/pdf,.txt,.csv,.json,.md,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/dicom,.dcm">
                        </div>
                        <textarea class="message-input" id="messageInput" placeholder="Ask about the document or use /note ..." rows="1"></textarea>
                        <button type="submit" class="send-button" id="sendButton" disabled>Send</button>
                    </form>
                </div>
            </div>

            <!-- Multimodal Analysis Dashboard -->
            <div class="analysis-dashboard" id="analysisDashboard">
                 <!-- ... (dashboard content remains the same) ... -->
                 <div class="dashboard-section">
                    <h3 class="dashboard-section-title">Document Viewer</h3>
                    <div id="documentViewerPlaceholder">
                        <div id="annotationToolbar">
                            <button class="tool-btn" title="Select"> S </button>
                            <button class="tool-btn" title="Draw">‚úèÔ∏è</button>
                            <button class="tool-btn" title="Highlight"> H </button>
                            <button class="tool-btn" title="Text"> T </button>
                            <button class="tool-btn" title="Comment">üí¨</button>
                        </div>
                        <span>Document Preview Area</span>
                    </div>
                </div>
                 <div class="dashboard-section">
                     <h3 class="dashboard-section-title">Detected Entities & Analysis</h3>
                     <div id="entityHighlightPlaceholder">
                         <p>Measurements: <span style="background-color: rgba(255, 165, 0, 0.3); padding: 2px 4px; border-radius: 3px;">15.2mm</span> <span class="confidence-score">(98%)</span></p>
                         <p class="placeholder-text">Detected items will be listed here...</p>
                     </div>
                 </div>
                 <div class="dashboard-section">
                     <h3 class="dashboard-section-title">Advanced Analytics</h3>
                     <div id="timeSeriesChartPlaceholder">Time-Series Visualization</div>
                     <div id="anomalyVizPlaceholder">Anomaly Detection Visualization</div>
                     <div id="predictiveVizPlaceholder">Predictive Modeling Visualization</div>
                     <button class="settings-button" style="margin-top: 1rem; width: auto;">Compare with History</button>
                 </div>
            </div>
        </div>

        <!-- Right Panel (Artifacts / Details) -->
        <div class="right-panel" id="rightPanel">
             <!-- ... (right panel content remains the same) ... -->
             <h3 style="color: var(--text-muted); text-align: center; margin-bottom: 1rem;">Details & Artifacts</h3>
            <div class="artifact">
                <div class="artifact-header"><span class="artifact-title">Extracted Table</span><span class="artifact-type">CSV</span></div>
                <div class="artifact-content"><pre><code>ID,Value,Unit\n1,15.2,mm\n2,10.0,cm</code></pre></div>
            </div>
             <div class="settings-section" style="margin-top: 2rem;">
                 <h3 class="settings-section-title">Collaboration</h3>
                 <div class="placeholder-text">Comments and annotations appear here.</div>
                 <button class="settings-button primary">Share Findings</button>
                 <button class="settings-button">Export Report (PDF)</button>
             </div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
         <!-- ... (settings panel content remains the same, fix placeholder images if needed) ... -->
          <div class="settings-header">
             <h2 class="settings-title">Settings & Configuration</h2>
             <button class="close-settings" id="closeSettings">&times;</button>
         </div>
         <div class="settings-tabs">
             <button class="settings-tab active" data-tab="general">General</button>
             <button class="settings-tab" data-tab="model">Model</button>
             <button class="settings-tab" data-tab="security">Security</button>
             <button class="settings-tab" data-tab="workflows">Workflows</button>
             <button class="settings-tab" data-tab="integrations">Integrations</button>
             <button class="settings-tab" data-tab="knowledge">Knowledge</button>
         </div>
         <div class="settings-content-wrapper">
             <!-- General Settings Tab -->
             <div class="settings-content active" id="settings-tab-general">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Conversation</h3>
                     <button id="viewEditHistoryBtn" class="settings-button">View / Edit History</button>
                     <button id="clearCurrentHistoryBtn" class="settings-button danger">Clear Current Session History</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Response Style</h3>
                     <div class="settings-option"><input type="radio" id="professionalStyle" name="responseStyle" value="professional"><label for="professionalStyle">Professional</label></div>
                     <div class="settings-option"><input type="radio" id="conciseStyle" name="responseStyle" value="concise"><label for="conciseStyle">Concise</label></div>
                     <div class="settings-option"><input type="radio" id="normalStyle" name="responseStyle" value="normal" checked><label for="normalStyle">Normal</label></div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Advanced Modes</h3>
                     <div class="settings-option"><input type="checkbox" id="thinkingModeToggle"><label for="thinkingModeToggle">Enable Extended Reasoning</label></div>
                     <div class="settings-option"><input type="checkbox" id="webSearchToggle"><label for="webSearchToggle">Enable Web Search</label></div>
                 </div>
             </div>
             <!-- Model Settings Tab -->
             <div class="settings-content" id="settings-tab-model">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Model Selection</h3>
                     <div class="settings-option">
                         <select id="modelSelector">
                             <option value="llama3:8b">Llama 3 8B (Default)</option>
                             <option value="claude-3-sonnet">Claude 3 Sonnet</option>
                             <option value="gpt-4-turbo">GPT-4 Turbo</option>
                             <option value="domain-specific-med-v1">Domain: Medical v1</option>
                             <option value="domain-specific-eng-v2">Domain: Engineering v2</option>
                         </select>
                     </div>
                     <div id="activeModelDisplay" style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;">Current: llama3:8b</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Creativity (Temperature)</h3>
                     <div class="slider-container">
                         <input type="range" id="temperatureSlider" min="0" max="1.5" step="0.1" value="0.7">
                         <span id="temperatureValue">0.7</span>
                     </div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Model Management</h3>
                     <button class="settings-button">Manage Model Versions</button>
                     <button class="settings-button">Start Fine-tuning Job</button>
                     <button class="settings-button">View Performance Metrics</button>
                     <button class="settings-button">Configure A/B Test</button>
                     <div id="modelPerfDashboard" class="placeholder-text" style="margin-top: 1rem;">Model Performance Dashboard Area</div>
                 </div>
             </div>
             <!-- Security Settings Tab -->
             <div class="settings-content" id="settings-tab-security">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Compliance</h3>
                     <div class="compliance-logos">
                         <!-- Replace with actual image paths or remove -->
                         <span class="tooltip"><img src="placeholder-soc2.png" alt="SOC 2"><span class="tooltiptext">SOC 2 Compliant</span></span>
                         <span class="tooltip"><img src="placeholder-hipaa.png" alt="HIPAA"><span class="tooltiptext">HIPAA Compliant</span></span>
                         <span class="tooltip"><img src="placeholder-gdpr.png" alt="GDPR"><span class="tooltiptext">GDPR Compliant</span></span>
                     </div>
                     <div class="settings-option" style="margin-top: 1rem;">
                         <label for="dataResidency" style="margin-left: 0; margin-right: 0.5rem; flex-shrink: 0;">Data Residency:</label>
                         <select id="dataResidency">
                             <option value="us">United States</option>
                             <option value="eu">European Union</option>
                             <option value="global">Global Default</option>
                         </select>
                     </div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Access Control</h3>
                     <button class="settings-button">Manage Users & Roles (RBAC)</button>
                     <button class="settings-button">Manage Document Permissions</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Auditing</h3>
                     <button class="settings-button">View Audit Logs</button>
                 </div>
             </div>
             <!-- Workflows Tab -->
             <div class="settings-content" id="settings-tab-workflows">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Workflow Management</h3>
                     <button class="settings-button">Create / Edit Workflows</button>
                     <div class="placeholder-text" style="margin-top: 1rem;">Workflow Editor Area</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Approval Settings</h3>
                     <button class="settings-button">Configure Approval Queues</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Domain Specific Enhancements</h3>
                      <div class="settings-option"><input type="checkbox" id="medTermToggle"><label for="medTermToggle">Enable Medical Terminology Validation</label></div>
                      <div class="settings-option"><input type="checkbox" id="equipSpecToggle"><label for="equipSpecToggle">Enable Equipment-Specific Analysis</label></div>
                 </div>
             </div>
              <!-- Integrations Tab -->
             <div class="settings-content" id="settings-tab-integrations">
                 <div class="settings-section">
                     <h3 class="settings-section-title">EHR / EMR Systems</h3>
                     <button class="settings-button primary">Connect to EHR/EMR</button>
                     <div class="placeholder-text">List of connected systems...</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Enterprise Systems</h3>
                     <button class="settings-button">Connect to SAP</button>
                     <button class="settings-button">Connect to Salesforce</button>
                     <div class="placeholder-text">List of connected systems...</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">API Access</h3>
                     <button class="settings-button">Manage API Keys</button>
                 </div>
             </div>
              <!-- Knowledge Base Tab -->
             <div class="settings-content" id="settings-tab-knowledge">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Knowledge Base Connection</h3>
                     <div class="settings-option">
                         <label for="kbEndpoint" style="margin-left:0; margin-right: 0.5rem;">Endpoint:</label>
                         <input type="text" id="kbEndpoint" placeholder="Enter KB API endpoint...">
                     </div>
                      <div class="settings-option"><input type="checkbox" id="ragToggle"><label for="ragToggle">Enable Retrieval-Augmented Generation (RAG)</label></div>
                     <button class="settings-button primary" style="margin-top: 1rem;">Connect</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Document Library Settings</h3>
                     <button class="settings-button">Configure Semantic Search</button>
                 </div>
             </div>
         </div>
    </div>

    <!-- File Upload Modal -->
    <div class="file-upload-modal" id="fileUploadModal">
         <!-- ... (file upload modal content remains the same) ... -->
         <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Upload & Process File</h2>
                <button class="close-modal" id="closeFileUploadModal">&times;</button>
            </div>
            <div class="file-upload-area" id="dropArea">
                <p class="file-upload-text">Drag & drop file or click to browse (PDF, DOCX, XLSX, DICOM, Images, Text...)</p>
                <img src="" alt="Image Preview" class="file-preview" id="imagePreview">
                <div class="file-info" id="fileInfoPreview">
                    <span style="font-size: 2rem;">üìÑ</span>
                    <span id="fileNamePreview"></span> (<span id="fileSizePreview"></span>)
                </div>
            </div>
            <div class="upload-options">
                <h4>Processing Options</h4>
                <div class="settings-option"><input type="checkbox" id="enableOcr" checked><label for="enableOcr">Enable OCR</label></div>
                <div class="settings-option"><input type="checkbox" id="extractTables" checked><label for="extractTables">Extract Tables</label></div>
                <div class="settings-option"><input type="checkbox" id="segmentDoc"><label for="segmentDoc">Segment Document Sections</label></div>
                <div class="settings-option">
                     <label for="workflowSelect" style="margin-left:0; margin-right: 0.5rem;">Apply Workflow:</label>
                     <select id="workflowSelect">
                         <option value="default">Default Analysis</option>
                         <option value="medical_report">Medical Report Review</option>
                         <option value="engineering_spec">Engineering Spec Check</option>
                         <option value="financial_audit">Financial Audit Assist</option>
                     </select>
                 </div>
            </div>
            <div class="file-upload-buttons">
                <button class="cancel-button" id="cancelUpload">Cancel</button>
                <button class="upload-button" id="confirmUpload" disabled>Upload & Analyze</button>
            </div>
        </div>
    </div>

     <!-- History Edit Modal -->
     <div class="file-upload-modal" id="historyEditModal" style="align-items: flex-start; padding-top: 5vh;">
          <!-- ... (history edit modal content remains the same) ... -->
          <div class="modal-content" style="max-width: 700px; max-height: 80vh; display: flex; flex-direction: column;">
             <div class="modal-header">
                 <h2 class="modal-title">Edit Conversation History</h2>
                 <button class="close-modal" id="closeHistoryModal">&times;</button>
             </div>
             <div id="historyEditContent" style="flex-grow: 1; overflow-y: auto; border: 1px solid var(--border-color); padding: 1rem; border-radius: 8px; background: var(--bg-primary);"></div>
             <div style="margin-top: 1rem; text-align: right;">
                 <button class="cancel-button" id="cancelHistoryEdit">Close</button>
             </div>
         </div>
     </div>

     <!-- Batch Processing Panel -->
     <div class="batch-processing-panel" id="batchProcessingPanel">
          <!-- ... (batch processing panel content remains the same) ... -->
          <div class="batch-panel-header">
             <h3 class="batch-panel-title">Batch Processing Queue</h3>
             <div class="batch-panel-actions">
                 <button class="settings-button primary" id="startNewBatchBtn">Start New Batch</button>
                 <button class="settings-button" id="closeBatchPanelBtn">&times;</button>
             </div>
         </div>
         <div class="batch-queue-list" id="batchQueueList">
             <div class="placeholder-text">No active batch jobs.</div>
         </div>
     </div>

    <!-- Notepad Container -->
    <div class="notepad-container" id="notepadContainer">
         <!-- ... (notepad container content remains the same) ... -->
         <div class="notepad-header">
            <h3 class="notepad-title">Notepad</h3>
            <div class="notepad-actions">
                <button class="notepad-action" id="notepadClearBtn" title="Clear notepad"><span>&#128465;</span></button>
                <button class="notepad-action" id="notepadCollapseBtn" title="Hide notepad"><span>&#10006;</span></button>
            </div>
        </div>
        <div class="notepad-content" id="notepadContent" contenteditable="true" spellcheck="true"></div>
        <div class="notepad-footer">
            <div class="notepad-status" id="notepadStatus">Ready</div>
            <div class="notepad-buttons">
                <button class="notepad-footer-btn" id="notepadSaveBtn">Save</button>
                <button class="notepad-footer-btn" id="notepadAskLLMBtn">Ask AI to edit</button>
            </div>
        </div>
    </div>

    <!-- 3. Include necessary JS libraries BEFORE your script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script> <!-- Marked library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script> <!-- Highlight.js library -->
    <!-- Optional: Add DOMPurify for sanitizeHTML -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>


    <script>
        // Initialize variables
        let currentViewMode = 'chat';
        // let notificationBadge; // <-- REMOVED: Redeclaration

        // --- DOM Elements ---
        const sidebar = document.getElementById('sidebar');
        const collapseToggleBtn = document.getElementById('collapseToggleBtn');
        const approvalQueueBtn = document.getElementById('approvalQueueBtn');
        const batchProcessingToggleBtn = document.getElementById('batchProcessingToggleBtn');
        const docLibraryBtn = document.getElementById('docLibraryBtn');
        const mainContent = document.getElementById('mainContent');
        const chatContainer = document.getElementById('chatContainer');
        const inputContainer = document.getElementById('inputContainer');
        const analysisDashboard = document.getElementById('analysisDashboard');
        const viewModeToggle = document.getElementById('viewModeToggle');
        const notificationsBtn = document.getElementById('notificationsBtn');
        // This is the correct declaration, gets the element by ID
        const notificationBadge = document.getElementById('notification-badge');
        const rightPanel = document.getElementById('rightPanel');
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsTabs = document.querySelectorAll('.settings-tab');
        const settingsContents = document.querySelectorAll('.settings-content');
        const closeSettings = document.getElementById('closeSettings');
        const fileUploadModal = document.getElementById('fileUploadModal');
        const enableOcr = document.getElementById('enableOcr');
        const extractTables = document.getElementById('extractTables');
        const segmentDoc = document.getElementById('segmentDoc');
        const workflowSelect = document.getElementById('workflowSelect');
        const batchProcessingPanel = document.getElementById('batchProcessingPanel');
        const batchQueueList = document.getElementById('batchQueueList');
        const startNewBatchBtn = document.getElementById('startNewBatchBtn');
        const closeBatchPanelBtn = document.getElementById('closeBatchPanelBtn');
        const chatForm = document.getElementById('chatForm');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const settingsBtn = document.getElementById('settingsBtn');
        const uploadFileBtn = document.getElementById('uploadFileBtn');
        const closeFileUploadModal = document.getElementById('closeFileUploadModal');
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('imagePreview');
        const fileInfoPreview = document.getElementById('fileInfoPreview');
        const fileNamePreview = document.getElementById('fileNamePreview');
        const fileSizePreview = document.getElementById('fileSizePreview');
        const confirmUpload = document.getElementById('confirmUpload');
        const cancelUpload = document.getElementById('cancelUpload');
        const clearCurrentHistoryBtn = document.getElementById('clearCurrentHistoryBtn');
        const viewEditHistoryBtn = document.getElementById('viewEditHistoryBtn');
        const historyEditModal = document.getElementById('historyEditModal');
        const closeHistoryModal = document.getElementById('closeHistoryModal');
        const cancelHistoryEdit = document.getElementById('cancelHistoryEdit');
        const historyEditContent = document.getElementById('historyEditContent');
        const newChatBtn = document.getElementById('newChatBtn');
        const responseStyleOptions = document.querySelectorAll('input[name="responseStyle"]');
        const conversationList = document.getElementById('conversationList');
        const conversationTitle = document.getElementById('conversationTitle');
        const conversationTitleInput = document.getElementById('conversationTitleInput');
        const modelSelector = document.getElementById('modelSelector');
        const activeModelDisplay = document.getElementById('activeModelDisplay');
        const temperatureSlider = document.getElementById('temperatureSlider');
        const temperatureValue = document.getElementById('temperatureValue');
        const thinkingModeToggle = document.getElementById('thinkingModeToggle');
        const webSearchToggle = document.getElementById('webSearchToggle');
        const templateBtn = document.getElementById('templateBtn');
        const templatesPopup = document.getElementById('templatesPopup');
        const dataResidency = document.getElementById('dataResidency');
        const medTermToggle = document.getElementById('medTermToggle');
        const equipSpecToggle = document.getElementById('equipSpecToggle');
        const ragToggle = document.getElementById('ragToggle');
        const kbEndpoint = document.getElementById('kbEndpoint');
        // Notepad DOM Elements
        const notepadContainer = document.getElementById('notepadContainer');
        const notepadContent = document.getElementById('notepadContent');
        const notepadToggleBtn = document.getElementById('notepadToggleBtn');
        const notepadCollapseBtn = document.getElementById('notepadCollapseBtn');
        const notepadClearBtn = document.getElementById('notepadClearBtn');
        const notepadStatus = document.getElementById('notepadStatus');
        const notepadSaveBtn = document.getElementById('notepadSaveBtn');
        const notepadAskLLMBtn = document.getElementById('notepadAskLLMBtn');


        // --- Global State ---
        let isBatchPanelVisible = false;
        let conversations = {};
        let currentConversationId = null;
        let selectedFile = null;
        let currentResponseStyle = 'normal';
        let currentTemperature = 0.7;
        let isThinkingModeEnabled = false;
        let isWebSearchEnabled = false;
        let selectedModel = 'llama3:8b';
        let isWaitingForResponse = false;
        let currentStreamingMessageElement = null;
        let currentAbortController = null;
        let currentDataResidency = 'us';
        let isMedTermEnabled = false;
        let isEquipSpecEnabled = false;
        let isRagEnabled = false;
        let currentKbEndpoint = '';
        let currentUploadOptions = { ocr: true, tables: true, segment: false, workflow: 'default' };


        // --- API Configuration ---
        const API_ENDPOINT = '/api/chat';
        const BATCH_API_ENDPOINT = '/api/batch';
        const WORKFLOW_API_ENDPOINT = '/api/workflows';

        // --- Helper Functions ---
        function generateId() { return Date.now().toString(36) + Math.random().toString(36).substring(2); }
        function formatBytes(bytes, decimals = 2) { if (bytes === 0) return '0 Bytes'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]; }
        function getFileIcon(mimeType) { if (mimeType.startsWith('image/')) return 'üñºÔ∏è'; if (mimeType.includes('pdf')) return 'üìÑ'; if (mimeType.includes('word')) return 'üìù'; if (mimeType.includes('sheet') || mimeType.includes('excel')) return 'üìä'; if (mimeType.startsWith('text/')) return 'üìú'; if (mimeType.includes('dicom')) return '‚öïÔ∏è'; return 'üìé'; }

        // 4. Define or import sanitizeHTML function
        function sanitizeHTML(htmlString) {
            // Use DOMPurify if available, otherwise a basic fallback (less secure)
            if (typeof DOMPurify !== 'undefined') {
                return DOMPurify.sanitize(htmlString);
            } else {
                console.warn("DOMPurify not loaded. Using basic text conversion for sanitization.");
                // Basic fallback: create a temporary element and get its text content
                // This strips all HTML tags, which might not be desired.
                // For real applications, ensure DOMPurify is loaded.
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlString; // Let the browser parse it
                return tempDiv.textContent || tempDiv.innerText || "";
            }
        }


        function addMessage(text, role, options = {}) {
            const { isHtml = false, messageId = generateId(), citations = null, confidence = null } = options;
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', `${role}-message`); // Use role for class
            messageDiv.dataset.messageId = messageId;

            let contentHtml = '';
            if (isHtml) {
                 // Sanitize HTML content before inserting if it comes from external source (like AI)
                 // If text is guaranteed safe internal HTML, sanitization might be skipped,
                 // but it's safer to sanitize content potentially influenced by external data.
                 // Assuming 'assistant' role content might be AI-generated HTML/Markdown
                 contentHtml = role === 'assistant' ? sanitizeHTML(marked.parse(text)) : text;
            } else {
                // Escape HTML characters for plain text to prevent XSS
                const tempDiv = document.createElement('div');
                tempDiv.textContent = text;
                let escapedText = tempDiv.innerHTML;

                // Find and link URLs after escaping
                const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
                contentHtml = escapedText.replace(urlRegex, url => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);
                contentHtml = contentHtml.replace(/\n/g, '<br>'); // Replace newlines with <br>
            }

            // Use innerHTML carefully
            messageDiv.innerHTML = contentHtml;

            // --- Citations ---
            if (citations && citations.length > 0) {
                const citationList = document.createElement('div');
                citationList.className = 'citation-source-list';
                let listHtml = '<h4>Sources:</h4><ul>';
                citations.forEach((cite, index) => {
                    const citeNum = index + 1;
                    const placeholder = `[${citeNum}]`;
                    // Use textContent to find placeholders safely, then replace in innerHTML
                    const regex = new RegExp(`\\[${citeNum}\\](?![\w-])`, 'g'); // Match [N] not followed by word chars
                    // Sanitize title/url before putting into attributes
                    const safeTitle = sanitizeHTML(cite.title || cite.url);
                    const safeUrl = sanitizeHTML(cite.url); // Basic sanitization for URL attribute
                    messageDiv.innerHTML = messageDiv.innerHTML.replace(regex, `<span class="citation" title="${safeTitle}" data-url="${safeUrl}">[${citeNum}]</span>`);
                    listHtml += `<li>[${citeNum}] <a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeTitle}</a></li>`;
                });
                listHtml += '</ul>';
                // Append the citation list HTML (already constructed with safe content)
                citationList.innerHTML = listHtml;
                messageDiv.appendChild(citationList);
            }

            // --- Confidence Score ---
            if (role === 'assistant' && confidence !== null) {
                 const confidenceSpan = document.createElement('span');
                 confidenceSpan.className = 'confidence-score';
                 confidenceSpan.textContent = `(${(confidence * 100).toFixed(0)}%)`;
                 // Append safely
                 messageDiv.appendChild(document.createTextNode(' ')); // Add space before
                 messageDiv.appendChild(confidenceSpan);
            }

            // --- Action Buttons ---
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-message-btn';
            deleteBtn.innerHTML = '&times;'; // Safe HTML entity
            deleteBtn.title = 'Delete message';
            deleteBtn.onclick = () => deleteMessageHandler(messageId);
            messageDiv.appendChild(deleteBtn);

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            // Use textContent for button text if possible, or safe innerHTML
            actionsDiv.innerHTML = `<button class="message-action-btn" title="Add Comment">üí¨</button><button class="message-action-btn" title="Send to Approval">‚úîÔ∏è</button><button class="message-action-btn" title="Copy">üìã</button>`;
            messageDiv.appendChild(actionsDiv);

            chatContainer.appendChild(messageDiv);

            // --- Syntax Highlighting ---
            if (role === 'assistant') {
                messageDiv.querySelectorAll('pre code').forEach((block) => {
                    // Check if hljs is loaded
                    if (typeof hljs !== 'undefined') {
                        hljs.highlightElement(block);
                        const pre = block.parentElement;
                        // Add copy button only if not already present
                        if (pre && pre.tagName === 'PRE' && !pre.querySelector('.copy-code-btn')) {
                            const copyBtn = document.createElement('button');
                            copyBtn.className = 'copy-code-btn';
                            copyBtn.textContent = 'Copy'; // Use textContent
                            copyBtn.onclick = () => copyCodeHandler(block, copyBtn);
                            pre.appendChild(copyBtn);
                        }
                    } else {
                        console.warn("highlight.js (hljs) not loaded. Skipping syntax highlighting.");
                    }
                });
            }
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
            return messageDiv;
        }

        function copyCodeHandler(block, button) {
            navigator.clipboard.writeText(block.textContent)
                .then(() => {
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy code: ', err);
                    button.textContent = 'Error';
                    setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                });
        }

        function addFilePlaceholderMessage(fileInfo) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'user-message'); // It's a user action
            messageDiv.dataset.messageId = generateId();

            const icon = getFileIcon(fileInfo.type);
            let fileHtml = '';

            // Sanitize file name and type before displaying
            const safeFileName = sanitizeHTML(fileInfo.name);
            const safeFileType = sanitizeHTML(fileInfo.type);

            if (fileInfo.type.startsWith('image/')) {
                // For images, the src comes from FileReader (base64), which is generally safe
                // if the file input isn't compromised, but still good practice to validate type.
                // Alt text should be sanitized.
                fileHtml = `<img src="${fileInfo.base64}" alt="${safeFileName}" style="max-width: 200px; max-height: 150px; border-radius: 0.5rem; margin-top: 0.5rem; display: block;">`;
            } else {
                fileHtml = `<div class="file-placeholder"><span>${icon}</span><span>${safeFileName} (${formatBytes(fileInfo.size)})</span></div>`;
            }

            // Construct the message content safely
            messageDiv.innerHTML = `File ready: ${fileHtml}`; // Insert the generated HTML

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-message-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.title = 'Remove file attachment';
            deleteBtn.onclick = () => {
                selectedFile = null;
                messageDiv.remove();
                updateButtonStates();
            };
            messageDiv.appendChild(deleteBtn);

            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
        }

        function removeStreamingIndicator() {
            if (currentStreamingMessageElement) {
                currentStreamingMessageElement.classList.remove('streaming');
                // Ensure hljs is available before calling
                if (typeof hljs !== 'undefined') {
                    currentStreamingMessageElement.querySelectorAll('pre code:not(.hljs)').forEach((block) => {
                        hljs.highlightElement(block);
                        const pre = block.parentElement;
                        if (pre && pre.tagName === 'PRE' && !pre.querySelector('.copy-code-btn')) {
                            const copyBtn = document.createElement('button');
                            copyBtn.className = 'copy-code-btn';
                            copyBtn.textContent = 'Copy';
                            copyBtn.onclick = () => copyCodeHandler(block, copyBtn);
                            pre.appendChild(copyBtn);
                        }
                    });
                } else {
                     console.warn("highlight.js (hljs) not loaded. Skipping final highlighting.");
                }
                currentStreamingMessageElement = null;
            }
            const typingIndicator = chatContainer.querySelector('.typing-indicator');
            if (typingIndicator) typingIndicator.remove();
        }

        function resetFileUpload() {
            fileInput.value = ''; // Clear the file input
            imagePreview.src = ''; // Clear preview source
            imagePreview.style.display = 'none';
            fileInfoPreview.style.display = 'none';
            fileNamePreview.textContent = ''; // Use textContent
            fileSizePreview.textContent = ''; // Use textContent
            selectedFile = null;
            confirmUpload.disabled = true;
            dropArea.classList.remove('dragover');
            // Reset options to default
            enableOcr.checked = true;
            extractTables.checked = true;
            segmentDoc.checked = false;
            workflowSelect.value = 'default';
            currentUploadOptions = { ocr: true, tables: true, segment: false, workflow: 'default' }; // Also reset internal state
        }

        function handleFiles(files) {
            if (files.length > 0) {
                const file = files[0];
                // Optional: Add checks for file size or type here before reading
                const reader = new FileReader();

                reader.onload = function(e) {
                    const base64Data = e.target.result;
                    selectedFile = {
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        base64: base64Data // The base64 string itself
                    };

                    if (file.type.startsWith('image/')) {
                        imagePreview.src = base64Data; // Set src for preview
                        imagePreview.alt = file.name; // Set alt text
                        imagePreview.style.display = 'block';
                        fileInfoPreview.style.display = 'none';
                    } else {
                        imagePreview.style.display = 'none';
                        fileNamePreview.textContent = file.name; // Use textContent
                        fileSizePreview.textContent = formatBytes(file.size); // Use textContent
                        fileInfoPreview.style.display = 'block'; // Show file info div
                    }
                    confirmUpload.disabled = false; // Enable upload button
                };

                reader.onerror = function(e) {
                    console.error("File reading error:", e);
                    alert("Error reading file.");
                    resetFileUpload(); // Reset UI on error
                };

                reader.readAsDataURL(file); // Read the file as Base64
            }
        }

        function updateButtonStates() {
            const messageText = messageInput.value.trim();
            // Disable if waiting for response OR if message is empty AND no file is selected
            sendButton.disabled = isWaitingForResponse || (messageText.length === 0 && !selectedFile);
        }

        function autoResizeTextarea() {
            messageInput.style.height = 'auto'; // Temporarily shrink to get correct scrollHeight
            let scrollHeight = messageInput.scrollHeight;
            const computedStyle = window.getComputedStyle(messageInput);
            const padding = parseInt(computedStyle.paddingTop) + parseInt(computedStyle.paddingBottom);
            const border = parseInt(computedStyle.borderTopWidth) + parseInt(computedStyle.borderBottomWidth);
            const actualContentHeight = scrollHeight - padding - border; // More accurate height

            const maxHeight = parseInt(computedStyle.maxHeight, 10);

            if (scrollHeight > maxHeight) {
                messageInput.style.height = maxHeight + 'px';
                messageInput.style.overflowY = 'auto'; // Show scrollbar if max height reached
            } else {
                messageInput.style.height = scrollHeight + 'px'; // Use scrollHeight directly seems common practice
                messageInput.style.overflowY = 'hidden'; // Hide scrollbar if not needed
            }
            updateButtonStates(); // Update button state whenever text changes
        }

        function loadConversations() {
            let storedConvs = null;
            try {
                storedConvs = localStorage.getItem('kynseyAiConversations');
                if (storedConvs) {
                    conversations = JSON.parse(storedConvs);
                    // Basic validation (check if it's an object)
                    if (typeof conversations !== 'object' || conversations === null) {
                        console.warn("Invalid conversation data in localStorage. Resetting.");
                        conversations = {};
                    }
                } else {
                    conversations = {};
                }
            } catch (e) {
                console.error("Error parsing conversations from localStorage:", e);
                conversations = {}; // Reset on error
            }


            const lastConvId = localStorage.getItem('kynseyAiLastConversationId');

            if (lastConvId && conversations[lastConvId]) {
                currentConversationId = lastConvId;
            } else if (Object.keys(conversations).length > 0) {
                // Find the most recent valid conversation if lastConvId is invalid
                 const sortedIds = Object.keys(conversations).sort((a, b) =>
                    new Date(conversations[b]?.createdAt || 0) - new Date(conversations[a]?.createdAt || 0)
                 );
                 currentConversationId = sortedIds[0] || null; // Fallback to null if sorting fails
            } else {
                currentConversationId = null; // No conversations exist
            }

            if (!currentConversationId) {
                 createNewConversation(); // Create one if none exist or couldn't be loaded
            } else {
                 renderConversationList();
                 loadConversation(currentConversationId); // Load the determined conversation
            }
        }

        function saveConversations() {
            try {
                localStorage.setItem('kynseyAiConversations', JSON.stringify(conversations));
                if (currentConversationId) {
                    localStorage.setItem('kynseyAiLastConversationId', currentConversationId);
                } else {
                    localStorage.removeItem('kynseyAiLastConversationId');
                }
            } catch (e) {
                console.error("Error saving conversations to localStorage:", e);
                // Potentially notify the user that settings/history might not be saved
                alert("Could not save conversation history. Storage might be full or unavailable.");
            }
        }

        function createNewConversation(setActive = true) {
            const newId = generateId();
            const timestamp = new Date();
            const defaultName = `Analysis ${timestamp.toLocaleDateString()} ${timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;

            // Ensure default values are set correctly
            conversations[newId] = {
                id: newId,
                name: defaultName,
                history: [], // Start with empty history
                model: selectedModel || 'llama3:8b', // Use current global or default
                temperature: currentTemperature || 0.7,
                thinkingMode: isThinkingModeEnabled || false,
                webSearch: isWebSearchEnabled || false,
                responseStyle: currentResponseStyle || 'normal',
                dataResidency: currentDataResidency || 'us',
                medTermEnabled: isMedTermEnabled || false,
                equipSpecEnabled: isEquipSpecEnabled || false,
                ragEnabled: isRagEnabled || false,
                kbEndpoint: currentKbEndpoint || '',
                createdAt: timestamp.toISOString(),
                associatedDocument: null,
                notepadContent: '', // Initialize notepad content for the new chat
                artifacts: [] // Initialize artifacts array
            };

            if (setActive) {
                currentConversationId = newId;
                // Don't call loadConversation here, as it might overwrite defaults
                // Just update UI elements directly for a new conversation
                chatContainer.innerHTML = ''; // Clear chat area
                addMessage('Hello! How can I help you today?', 'assistant'); // Add initial message
                conversationTitle.textContent = defaultName;
                conversationTitleInput.value = defaultName;
                resetFileUpload();
                messageInput.value = '';
                autoResizeTextarea();
                updateSettingsUI(); // Reflect the defaults in the settings panel
                updateButtonStates();
                rightPanel.innerHTML = '<h3 style="color: var(--text-muted); text-align: center; margin-bottom: 1rem;">Details & Artifacts</h3>'; // Reset right panel
                rightPanel.classList.remove('visible');
                loadNotepadContent(); // Load/clear notepad for the new conversation
                renderConversationList(); // Update the list display
                highlightActiveConversation(); // Highlight the new one
                saveConversations(); // Save the new state
            }
            return newId;
        }


        function loadConversation(id) {
            if (!conversations[id]) {
                console.error("Conversation not found:", id);
                // Attempt to load the first available conversation or create a new one
                const availableIds = Object.keys(conversations);
                if (availableIds.length > 0) {
                    console.warn(`Falling back to conversation: ${availableIds[0]}`);
                    loadConversation(availableIds[0]);
                } else {
                    console.warn("No conversations available. Creating a new one.");
                    createNewConversation(); // This will set currentConversationId and load defaults
                }
                return;
            }

            currentConversationId = id;
            const conv = conversations[id];

            // --- Update Global State from Loaded Conversation ---
            selectedModel = conv.model || 'llama3:8b';
            currentTemperature = conv.temperature ?? 0.7; // Use nullish coalescing for 0 temp
            isThinkingModeEnabled = conv.thinkingMode || false;
            isWebSearchEnabled = conv.webSearch || false;
            currentResponseStyle = conv.responseStyle || 'normal';
            currentDataResidency = conv.dataResidency || 'us';
            isMedTermEnabled = conv.medTermEnabled || false;
            isEquipSpecEnabled = conv.equipSpecEnabled || false;
            isRagEnabled = conv.ragEnabled || false;
            currentKbEndpoint = conv.kbEndpoint || '';

            // --- Update UI Elements ---
            updateSettingsUI(); // Reflect loaded settings in the panel
            conversationTitle.textContent = conv.name; // Use textContent
            conversationTitleInput.value = conv.name;

            // --- Render Chat History ---
            chatContainer.innerHTML = ''; // Clear previous messages
            if (conv.history && conv.history.length > 0) {
                conv.history.forEach(msg => {
                    // Ensure message format is valid before adding
                    if (msg && typeof msg.content === 'string' && typeof msg.role === 'string') {
                         addMessage(msg.content, msg.role, {
                             messageId: msg.id || generateId(), // Generate ID if missing
                             isHtml: msg.role === 'assistant', // Assume assistant messages might contain HTML/Markdown
                             citations: msg.citations,
                             confidence: msg.confidence
                         });
                    } else {
                        console.warn("Skipping invalid message in history:", msg);
                    }
                });
            } else {
                // If history is empty, add the initial greeting
                const initialMsgId = generateId();
                addMessage('Hello! How can I help you today?', 'assistant', { messageId: initialMsgId });
                // Optionally add this greeting to the history array if you want it saved
                // conv.history = [{ role: 'assistant', content: 'Hello! How can I help you today?', id: initialMsgId }];
            }

             // --- Update Dashboard View ---
             const docViewer = document.getElementById('documentViewerPlaceholder');
             if (currentViewMode === 'dashboard' && docViewer) {
                 if (conv.associatedDocument) {
                     docViewer.innerHTML = `<span>Loading ${sanitizeHTML(conv.associatedDocument.name)}...</span>`; // Sanitize name
                 } else {
                     docViewer.innerHTML = `<span>No document loaded. Upload one.</span>`;
                 }
             }

            // --- Render Artifacts ---
            rightPanel.innerHTML = '<h3 style="color: var(--text-muted); text-align: center; margin-bottom: 1rem;">Details & Artifacts</h3>'; // Clear previous artifacts
            rightPanel.classList.remove('visible'); // Hide initially
            if (conv.artifacts && conv.artifacts.length > 0) {
                conv.artifacts.forEach(renderArtifact); // Render artifacts will make panel visible if needed
            }

            // --- Reset Input & State ---
            resetFileUpload(); // Clear any pending file uploads
            messageInput.value = '';
            autoResizeTextarea();
            updateButtonStates();
            highlightActiveConversation(); // Ensure correct item is highlighted in the list
            loadNotepadContent(); // Load notepad content specific to this conversation

            // --- Save (to update last loaded ID) ---
            saveConversations(); // Save potentially updated history (e.g., added initial message) and last loaded ID
        }


        function renderConversationList() {
            conversationList.innerHTML = ''; // Clear existing list
            // Sort by creation date, newest first
            const sortedIds = Object.keys(conversations).sort((a, b) => {
                const dateA = new Date(conversations[a]?.createdAt || 0);
                const dateB = new Date(conversations[b]?.createdAt || 0);
                return dateB - dateA; // Descending order
            });

            sortedIds.forEach(id => {
                const conv = conversations[id];
                if (!conv) return; // Skip if conversation data is somehow missing

                const item = document.createElement('button');
                item.className = 'sidebar-item';
                item.dataset.convId = id;
                item.title = conv.name; // Set title attribute for tooltips

                // Use textContent for safety, sanitize if necessary but likely overkill here
                const iconSpan = document.createElement('span');
                iconSpan.innerHTML = '&#128172;'; // Chat bubble icon

                const textSpan = document.createElement('span');
                textSpan.className = 'sidebar-item-text';
                textSpan.textContent = conv.name; // Use textContent for the name

                item.appendChild(iconSpan);
                item.appendChild(textSpan);

                item.onclick = () => loadConversation(id);

                // Add context menu for delete (optional)
                item.oncontextmenu = (e) => {
                    e.preventDefault();
                    if (confirm(`Delete conversation "${conv.name}"?`)) {
                        deleteConversation(id);
                    }
                };

                conversationList.appendChild(item);
            });

            highlightActiveConversation(); // Highlight the currently active one
        }


        function highlightActiveConversation() {
            document.querySelectorAll('.sidebar-item').forEach(item => {
                item.classList.toggle('active', item.dataset.convId === currentConversationId);
            });
        }

        function renameConversation(id, newName) {
            const trimmedName = newName.trim();
            if (conversations[id] && trimmedName) {
                conversations[id].name = trimmedName;
                saveConversations();
                renderConversationList(); // Update the list display
                // If renaming the current conversation, update the title display
                if (id === currentConversationId) {
                    conversationTitle.textContent = trimmedName; // Use textContent
                    conversationTitleInput.value = trimmedName; // Also update the input field's value
                }
            } else if (id === currentConversationId) {
                 // If new name is empty, revert the input field to the old name
                 conversationTitleInput.value = conversations[id]?.name || "Chat";
            }
        }

        function deleteConversation(id) {
            if (!conversations[id]) return;

            // Prevent deleting the last conversation
            if (Object.keys(conversations).length <= 1) {
                alert("Cannot delete the last conversation.");
                return;
            }

            // Confirmation dialog
            if (confirm(`Are you sure you want to delete the conversation "${conversations[id].name}"? This cannot be undone.`)) {
                delete conversations[id]; // Remove from the object

                // If the deleted conversation was the active one, load another one
                if (currentConversationId === id) {
                    currentConversationId = null; // Reset current ID
                    // Find the most recent remaining conversation
                    const remainingIds = Object.keys(conversations).sort((a, b) =>
                         new Date(conversations[b]?.createdAt || 0) - new Date(conversations[a]?.createdAt || 0)
                    );
                    if (remainingIds.length > 0) {
                        loadConversation(remainingIds[0]); // Load the newest remaining
                    } else {
                        // This case should technically not be reached due to the "last conversation" check,
                        // but as a fallback, create a new one.
                        createNewConversation();
                    }
                }
                saveConversations(); // Save the updated state
                renderConversationList(); // Re-render the list without the deleted item
            }
        }

        function deleteMessageHandler(messageId) {
            if (!currentConversationId || !conversations[currentConversationId]) return;

            const conversation = conversations[currentConversationId];
            const messageIndex = conversation.history.findIndex(msg => msg.id === messageId);

            if (messageIndex > -1) {
                // Remove the message from the history array
                conversation.history.splice(messageIndex, 1);

                // Remove the message element from the DOM
                const messageElement = chatContainer.querySelector(`[data-message-id="${messageId}"]`);
                if (messageElement) {
                    messageElement.remove();
                }

                saveConversations(); // Save the change
                console.log("Deleted message:", messageId);
            } else {
                console.warn("Message ID not found in history:", messageId);
                // Still try to remove from DOM just in case it exists visually but not in history
                const messageElement = chatContainer.querySelector(`[data-message-id="${messageId}"]`);
                if (messageElement) {
                     console.warn("Removing message element from DOM even though not found in history array.");
                     messageElement.remove();
                }
            }
        }

        function showHistoryEditModal() {
            if (!currentConversationId || !conversations[currentConversationId]) return;

            const conversation = conversations[currentConversationId];
            historyEditContent.innerHTML = ''; // Clear previous content

            if (!conversation.history || conversation.history.length === 0) {
                historyEditContent.innerHTML = '<p style="color: var(--text-muted);">History is empty.</p>';
            } else {
                conversation.history.forEach(msg => {
                    if (!msg || typeof msg.role !== 'string' || typeof msg.content !== 'string') {
                        console.warn("Skipping invalid message during history edit display:", msg);
                        return; // Skip invalid messages
                    }

                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = `margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px dashed var(--border-color); position: relative;`; // Added relative positioning
                    itemDiv.dataset.messageId = msg.id || generateId(); // Ensure there's an ID

                    const roleLabel = document.createElement('strong');
                    roleLabel.textContent = msg.role.charAt(0).toUpperCase() + msg.role.slice(1);
                    roleLabel.style.color = msg.role === 'user' ? 'var(--accent-primary)' : 'var(--text-secondary)';
                    roleLabel.style.cssText += `display: block; margin-bottom: 0.3rem;`;

                    const contentDiv = document.createElement('div');
                    // Display content as pre-formatted text to preserve whitespace/newlines
                    contentDiv.textContent = msg.content;
                    contentDiv.style.cssText = `white-space: pre-wrap; font-size: 0.9rem; margin-right: 70px;`; // Add margin to avoid overlap with button

                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times; Delete'; // Use innerHTML for the times symbol
                    deleteBtn.style.cssText = `position: absolute; top: 0; right: 0; background: none; border: 1px solid var(--danger-color); color: var(--danger-color); padding: 0.2rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;`;
                    deleteBtn.onclick = () => {
                        // Confirm before deleting from the modal view
                        if (confirm(`Delete this ${msg.role} message?\n\n"${msg.content.substring(0, 50)}..."`)) {
                            deleteMessageHandler(itemDiv.dataset.messageId); // Use the actual delete handler
                            itemDiv.remove(); // Remove from modal view
                            // Check if the modal content is now empty
                            if (historyEditContent.childElementCount === 0) {
                                historyEditContent.innerHTML = '<p style="color: var(--text-muted);">History is empty.</p>';
                            }
                        }
                    };

                    itemDiv.appendChild(roleLabel);
                    itemDiv.appendChild(contentDiv);
                    itemDiv.appendChild(deleteBtn); // Append button last
                    historyEditContent.appendChild(itemDiv);
                });
            }
            historyEditModal.classList.add('active'); // Show the modal
        }

        function renderArtifact(artifact) {
            if (!artifact || !artifact.content) {
                console.warn("Attempted to render invalid artifact:", artifact);
                return;
            }

            // Ensure right panel is visible
            if (!rightPanel.classList.contains('visible')) {
                rightPanel.classList.add('visible');
            }

            // Remove the initial placeholder text if it exists
            const placeholder = rightPanel.querySelector('h3[style*="text-align: center"]');
            if (placeholder && placeholder.textContent.includes('Details & Artifacts')) {
                placeholder.remove();
            }

            const artifactId = artifact.id || generateId();
            // Check if artifact already exists to prevent duplicates
            if (rightPanel.querySelector(`[data-artifact-id="${artifactId}"]`)) {
                console.log("Artifact already rendered:", artifactId);
                return;
            }


            const artifactDiv = document.createElement('div');
            artifactDiv.className = 'artifact';
            artifactDiv.dataset.artifactId = artifactId;

            const type = artifact.type || 'text';
            const title = sanitizeHTML(artifact.title || `Artifact (${type})`); // Sanitize title
            const safeType = sanitizeHTML(type); // Sanitize type

            let contentHtml = '';

            // Sanitize content based on type
            const sanitizedContent = sanitizeHTML(artifact.content); // Basic sanitization first

            if (type === 'code' || type === 'csv') { // Treat CSV like code for pre/code block
                const lang = sanitizeHTML(artifact.language || (type === 'csv' ? 'csv' : '')); // Sanitize language
                // Further escape HTML within the code block before putting inside <pre><code>
                const codeElement = document.createElement('code');
                codeElement.className = `language-${lang}`;
                codeElement.textContent = artifact.content; // Use textContent to let browser handle escaping
                contentHtml = `<pre>${codeElement.outerHTML}</pre>`;
            } else if (type === 'markdown') {
                 // Ensure marked is loaded and sanitize its output
                 if (typeof marked !== 'undefined') {
                     contentHtml = sanitizeHTML(marked.parse(artifact.content)); // Sanitize the HTML output of marked
                 } else {
                     console.warn("Marked library not loaded. Displaying Markdown as preformatted text.");
                     contentHtml = `<pre>${sanitizedContent.replace(/\n/g, '<br>')}</pre>`; // Fallback
                 }
            } else { // Default to plain text, preserve line breaks
                contentHtml = `<p>${sanitizedContent.replace(/\n/g, '<br>')}</p>`;
            }

            artifactDiv.innerHTML = `
                <div class="artifact-header">
                    <span class="artifact-title">${title}</span>
                    <span class="artifact-type">${safeType}</span>
                </div>
                <div class="artifact-content">${contentHtml}</div>
            `;

            rightPanel.appendChild(artifactDiv);

            // Apply syntax highlighting and add copy button AFTER appending to DOM
            if (type === 'code' || type === 'csv') {
                artifactDiv.querySelectorAll('pre code').forEach((block) => {
                     if (typeof hljs !== 'undefined') {
                         hljs.highlightElement(block);
                         const pre = block.parentElement;
                         if (pre && pre.tagName === 'PRE' && !pre.querySelector('.copy-code-btn')) {
                             const copyBtn = document.createElement('button');
                             copyBtn.className = 'copy-code-btn';
                             copyBtn.textContent = 'Copy';
                             copyBtn.onclick = () => copyCodeHandler(block, copyBtn);
                             // pre.style.position = 'relative'; // Ensure parent is relative for absolute positioning of button
                             pre.appendChild(copyBtn);
                         }
                     } else {
                         console.warn("highlight.js (hljs) not loaded. Skipping artifact highlighting.");
                     }
                });
            }

            // Add artifact to conversation state if not already there
            const currentConv = conversations[currentConversationId];
            if (currentConv) {
                if (!currentConv.artifacts) {
                    currentConv.artifacts = [];
                }
                // Add only if it doesn't exist by ID
                if (!currentConv.artifacts.some(a => a.id === artifactId)) {
                     // Store a reference or the full artifact data
                     currentConv.artifacts.push({ ...artifact, id: artifactId }); // Store a copy with ensured ID
                     saveConversations(); // Save the updated conversation state
                }
            }
        }


        function toggleViewMode() {
            const docViewer = document.getElementById('documentViewerPlaceholder');
            const currentConv = conversations[currentConversationId];

            if (currentViewMode === 'chat') {
                currentViewMode = 'dashboard';
                mainContent.classList.add('dashboard-view');
                inputContainer.style.display = 'none'; // Hide chat input
                analysisDashboard.style.display = 'flex'; // Show dashboard sections
                viewModeToggle.textContent = 'Chat View'; // Update button text

                // Update document viewer based on current conversation
                if (docViewer) {
                     if (currentConv?.associatedDocument) {
                         docViewer.innerHTML = `<span>Loading ${sanitizeHTML(currentConv.associatedDocument.name)}...</span>`;
                     } else {
                         docViewer.innerHTML = `<span>No document loaded.</span>`;
                     }
                }
                // Ensure right panel (for artifacts/details) is visible in dashboard mode
                rightPanel.classList.add('visible');

            } else { // Switching back to chat view
                currentViewMode = 'chat';
                mainContent.classList.remove('dashboard-view');
                inputContainer.style.display = 'block'; // Show chat input
                analysisDashboard.style.display = 'none'; // Hide dashboard sections
                viewModeToggle.textContent = 'Dashboard View'; // Update button text

                // Hide right panel only if it contains no artifacts
                if (!rightPanel.querySelector('.artifact')) {
                    rightPanel.classList.remove('visible');
                }
            }
        }

        function toggleBatchPanel() {
            isBatchPanelVisible = !isBatchPanelVisible;
            batchProcessingPanel.classList.toggle('visible', isBatchPanelVisible);
            if (isBatchPanelVisible) {
                fetchBatchJobs(); // Fetch jobs when panel becomes visible
            }
        }

        // Mock function - replace with actual API call
        async function fetchBatchJobs() {
            console.log("Fetching batch jobs...");
            batchQueueList.innerHTML = '<div class="placeholder-text">Loading...</div>'; // Show loading state

            try {
                // Simulate API call delay
                await new Promise(resolve => setTimeout(resolve, 1000));

                // --- Mock Data ---
                const mockJobs = [
                    { id: 'batch001', name: 'Batch_Report_01 (100 docs)', status: 'processing', progress: 75 },
                    { id: 'batch002', name: 'Hist_Analysis (5 docs)', status: 'completed', progress: 100 },
                    { id: 'batch003', name: 'Urgent_Review (1 doc)', status: 'failed', progress: 0 },
                    { id: 'batch004', name: 'Pending_Uploads (20 docs)', status: 'pending', progress: 0 } // Added pending state
                ];
                // --- End Mock Data ---

                // Replace with actual fetch:
                // const response = await fetch(BATCH_API_ENDPOINT);
                // if (!response.ok) throw new Error(`Failed to fetch batch jobs: ${response.statusText}`);
                // const jobs = await response.json();
                const jobs = mockJobs; // Use mock data for now

                batchQueueList.innerHTML = ''; // Clear loading state

                if (jobs.length === 0) {
                    batchQueueList.innerHTML = '<div class="placeholder-text">No active batch jobs.</div>';
                    return;
                }

                jobs.forEach(job => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'batch-item';
                    itemDiv.dataset.jobId = job.id;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'batch-item-name';
                    nameSpan.textContent = job.name; // Use textContent

                    const statusDiv = document.createElement('div');
                    statusDiv.style.display = 'flex';
                    statusDiv.style.alignItems = 'center';

                    const statusSpan = document.createElement('span');
                    statusSpan.className = `batch-item-status ${job.status}`; // Use job status for class
                    statusSpan.textContent = job.status.charAt(0).toUpperCase() + job.status.slice(1); // Capitalize status

                    statusDiv.appendChild(statusSpan);

                    // Add progress bar only if processing or completed
                    if (job.status === 'processing' || job.status === 'completed') {
                        const progressDiv = document.createElement('div');
                        progressDiv.className = 'batch-item-progress';
                        const progressBar = document.createElement('div');
                        progressBar.className = 'batch-item-progress-bar';
                        progressBar.style.width = `${job.progress || 0}%`; // Use job progress
                        progressDiv.appendChild(progressBar);
                        statusDiv.appendChild(progressDiv);
                    }

                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(statusDiv);
                    batchQueueList.appendChild(itemDiv);
                });

            } catch (error) {
                console.error("Error fetching batch jobs:", error);
                batchQueueList.innerHTML = '<div class="placeholder-text" style="color: var(--danger-color);">Error loading batch jobs.</div>';
            }
        }

        function switchSettingsTab(tabName) {
            // Deactivate all tabs and content first
            settingsTabs.forEach(tab => tab.classList.remove('active'));
            settingsContents.forEach(content => content.classList.remove('active'));

            // Activate the selected tab
            const activeTab = document.querySelector(`.settings-tab[data-tab="${tabName}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }

            // Activate the corresponding content
            const activeContent = document.getElementById(`settings-tab-${tabName}`);
            if (activeContent) {
                activeContent.classList.add('active');
            } else {
                console.warn(`Settings content for tab "${tabName}" not found.`);
            }
        }

        function updateSettingsUI() {
            // Update controls based on the global state variables
            // (which should have been loaded from the current conversation)
            modelSelector.value = selectedModel;
            activeModelDisplay.textContent = `Current: ${selectedModel}`; // Use textContent
            temperatureSlider.value = currentTemperature;
            temperatureValue.textContent = currentTemperature.toFixed(1); // Use textContent
            thinkingModeToggle.checked = isThinkingModeEnabled;
            webSearchToggle.checked = isWebSearchEnabled;

            // Update response style radio buttons
            const styleRadioButton = document.querySelector(`input[name="responseStyle"][value="${currentResponseStyle}"]`);
            if (styleRadioButton) {
                styleRadioButton.checked = true;
            } else {
                // Fallback if the saved style is invalid, check 'normal'
                document.querySelector('input[name="responseStyle"][value="normal"]').checked = true;
            }

            dataResidency.value = currentDataResidency;
            medTermToggle.checked = isMedTermEnabled;
            equipSpecToggle.checked = isEquipSpecEnabled;
            ragToggle.checked = isRagEnabled;
            kbEndpoint.value = currentKbEndpoint;
        }


        // --- Notepad Functions ---
        function saveNotepadContent() {
            const content = notepadContent.innerHTML; // Get HTML content
            // Save globally (optional, could be removed if only per-conversation is needed)
            // localStorage.setItem('kynseyAiNotepadContent_global', content);

            // Save to the current conversation object
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].notepadContent = content;
                saveConversations(); // Save the entire conversations object (includes the updated notepad)
                console.log("Notepad content saved to conversation:", currentConversationId);
            } else {
                console.warn("Cannot save notepad content: No active conversation.");
            }
        }

        function loadNotepadContent() {
            let contentToLoad = '';
            // Try loading from the current conversation first
            if (currentConversationId && conversations[currentConversationId]) {
                 // Use the content from the conversation object, default to empty string if null/undefined
                contentToLoad = conversations[currentConversationId].notepadContent || '';
                console.log("Loading notepad from current conversation:", currentConversationId);
            } else {
                // Fallback (optional): Load from global storage if no active conversation
                // contentToLoad = localStorage.getItem('kynseyAiNotepadContent_global') || '';
                // console.log("Loading notepad from global storage (no active conversation).");
                 console.log("No active conversation to load notepad content from.");
                 contentToLoad = ''; // Default to empty if no conversation
            }

            // Set the content and update status
            notepadContent.innerHTML = contentToLoad; // Set HTML content
            updateNotepadStatus('Ready');
        }

        function updateNotepadStatus(message) {
            notepadStatus.textContent = message; // Use textContent
            notepadStatus.style.opacity = '1';
            // Clear any existing timeout to prevent premature fading
            if (window.notepadStatusTimeout) {
                clearTimeout(window.notepadStatusTimeout);
            }
            // Set a new timeout to fade the message
            window.notepadStatusTimeout = setTimeout(() => {
                notepadStatus.style.opacity = '0.7';
            }, 1500);
        }

        function initializeNotepad() {
            loadNotepadContent(); // Load initial content based on the loaded conversation
            notepadContent.setAttribute('data-placeholder', 'Type your notes here... Use /note in chat or ask AI to edit.');
            updateNotepadStatus('Ready');

            // Define the function for AI updates globally or attach to window
            window.updateNotepadFromAI = function(newContentHtml, highlightChanges = true) {
                console.log("Updating notepad from AI.");
                // Sanitize the HTML received from the AI before inserting
                const sanitizedHtml = sanitizeHTML(newContentHtml);
                notepadContent.innerHTML = sanitizedHtml;

                if (highlightChanges) {
                    // Apply highlight to top-level block elements for visual feedback
                    // Query direct children or common block elements within the sanitized content
                    const elements = notepadContent.querySelectorAll(':scope > p, :scope > li, :scope > h1, :scope > h2, :scope > h3, :scope > h4, :scope > h5, :scope > h6, :scope > div, :scope > pre, :scope > blockquote, :scope > table');
                    elements.forEach(el => {
                        // Check if element has content
                        if (el.textContent.trim().length > 0) {
                            el.classList.add('ai-edit-highlight');
                            // Rely on CSS animation to fade out, no need for JS timeout to remove class
                        }
                    });
                }

                saveNotepadContent(); // Save the updated content
                updateNotepadStatus('Updated by AI');

                // Ensure notepad is visible after AI update
                if (!notepadContainer.classList.contains('visible')) {
                    notepadContainer.classList.add('visible');
                }
            };
        }

        function handleAINotepadEdit(aiMessage) {
            // Regex to find the notepad content block, case-insensitive and multiline
            const notepadRegex = /\[NOTEPAD:BEGIN\]([\s\S]*?)\[NOTEPAD:END\]/im;
            const match = aiMessage.match(notepadRegex);

            if (match && match[1]) {
                console.log("Found notepad edit command in AI response.");
                const notepadContentHtml = match[1].trim(); // Extract content

                // Check if the update function exists
                if (typeof window.updateNotepadFromAI === 'function') {
                    // Assume AI provides usable HTML (will be sanitized by updateNotepadFromAI)
                    // If AI provides Markdown, you would parse it here first:
                    // const parsedHtml = (typeof marked !== 'undefined') ? marked.parse(notepadContentHtml) : notepadContentHtml;
                    // window.updateNotepadFromAI(parsedHtml);
                    window.updateNotepadFromAI(notepadContentHtml); // Pass the raw HTML block
                } else {
                    console.error("updateNotepadFromAI function is not defined.");
                }

                // Return the original message *without* the notepad block
                return aiMessage.replace(notepadRegex, '').trim();
            }
            // If no notepad block found, return the original message unchanged
            return aiMessage;
        }


        // --- Core API Interaction (Modified to handle notepad edits) ---
        async function sendMessageToLLM() {
            const messageText = messageInput.value.trim();
            const currentConv = conversations[currentConversationId];

            if (!currentConv) {
                alert("Error: No active conversation selected.");
                return;
            }
            // Proceed only if there's text OR a file selected
            if (!messageText && !selectedFile) {
                return; // Nothing to send
            }

            isWaitingForResponse = true;
            updateButtonStates(); // Disable send button

            // Abort previous request if any
            if (currentAbortController) {
                currentAbortController.abort();
                console.log("Aborted previous API request.");
            }
            currentAbortController = new AbortController();

            const userMessageId = generateId();

            // Add user message to chat and history only if there is text
            if (messageText) {
                addMessage(messageText, 'user', { messageId: userMessageId }); // Use 'user' role consistently
                currentConv.history.push({ role: 'user', content: messageText, id: userMessageId });
            }

            // Handle file attachment
            let filePayload = null;
            const stagedFile = selectedFile; // Stage the file to be sent
            if (stagedFile) {
                 // Add placeholder message *after* potential text message
                 addFilePlaceholderMessage(stagedFile);
                 filePayload = {
                     name: stagedFile.name,
                     type: stagedFile.type,
                     base64: stagedFile.base64, // Send the base64 data
                     // Include processing options selected in the modal
                     processingOptions: {
                         ocr: currentUploadOptions.ocr,
                         extractTables: currentUploadOptions.tables,
                         segment: currentUploadOptions.segment,
                         workflowId: currentUploadOptions.workflow
                     }
                 };
                 // Associate document with conversation if not already done
                 if (!currentConv.associatedDocument) {
                     currentConv.associatedDocument = { name: stagedFile.name, type: stagedFile.type, id: generateId() };
                     // Update dashboard view if currently active
                     if (currentViewMode === 'dashboard') {
                         const docViewer = document.getElementById('documentViewerPlaceholder');
                         if (docViewer) {
                             docViewer.innerHTML = `<span>Loading ${sanitizeHTML(stagedFile.name)}...</span>`;
                         }
                     }
                 }
                 selectedFile = null; // Clear selected file after staging it
                 resetFileUpload(); // Reset the upload modal UI elements
            }


            messageInput.value = ''; // Clear input field
            autoResizeTextarea(); // Resize input field

            // Construct payload for the API
            const payload = {
                message: messageText, // Send the user's text message
                // Send a reasonable amount of recent history (e.g., last 10 turns = 20 messages)
                // Ensure history items are valid before sending
                history: currentConv.history?.filter(msg => msg && msg.role && typeof msg.content === 'string').slice(-20) || [],
                model: selectedModel,
                temperature: currentTemperature,
                responseStyle: currentResponseStyle,
                thinkingMode: isThinkingModeEnabled,
                webSearch: isWebSearchEnabled,
                // Include domain-specific flags
                enableMedicalTerms: isMedTermEnabled,
                enableEquipmentAnalysis: isEquipSpecEnabled,
                // Include RAG settings
                enableRag: isRagEnabled,
                knowledgeBaseEndpoint: isRagEnabled ? currentKbEndpoint : null,
                // Include file payload if a file was staged
                file: filePayload,
                // Include conversation context if needed by backend
                conversationId: currentConversationId,
                dataResidency: currentDataResidency, // Send data residency preference
            };

            removeStreamingIndicator(); // Remove any previous indicators
            const assistantMessageId = generateId();
            // Add placeholder for assistant response
            currentStreamingMessageElement = addMessage("", 'assistant', { messageId: assistantMessageId });
            currentStreamingMessageElement.classList.add('streaming'); // Add streaming class for visual feedback

            let fullResponseText = "";
            let receivedCitations = null;
            let receivedArtifacts = []; // Store artifacts received during streaming
            let receivedConfidence = null;

            try {
                console.log("Sending payload (structure):", { ...payload, file: payload.file ? {...payload.file, base64: "[omitted]"} : null, history: `[${payload.history?.length || 0} items]` });

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    signal: currentAbortController.signal // Pass the abort signal
                });

                if (!response.ok) {
                    // Try to read error message from response body
                    let errorBody = await response.text();
                    try { errorBody = JSON.parse(errorBody).error || errorBody; } catch { /* ignore parsing error */ }
                    throw new Error(`API Error (${response.status}): ${errorBody || response.statusText}`);
                }

                // --- Process Streaming Response ---
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break; // Stream finished

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // Keep potential partial line in buffer

                    for (const line of lines) {
                        if (line.trim().startsWith('data:')) {
                            try {
                                const jsonData = JSON.parse(line.substring(5).trim());

                                // Handle different event types from the stream
                                if (jsonData.type === 'chunk' && typeof jsonData.content === 'string') {
                                    fullResponseText += jsonData.content;
                                    // Update message bubble content progressively (parse Markdown)
                                    if (currentStreamingMessageElement) {
                                         // Ensure marked is loaded
                                         if (typeof marked !== 'undefined') {
                                             currentStreamingMessageElement.innerHTML = sanitizeHTML(marked.parse(fullResponseText));
                                         } else {
                                             // Fallback: display raw text if marked is missing
                                             currentStreamingMessageElement.textContent = fullResponseText;
                                         }
                                         chatContainer.scrollTop = chatContainer.scrollHeight; // Scroll down
                                    }
                                } else if (jsonData.type === 'citation') {
                                    receivedCitations = jsonData.data; // Store citation data
                                } else if (jsonData.type === 'artifact') {
                                    receivedArtifacts.push(jsonData.data); // Store artifact data
                                    renderArtifact(jsonData.data); // Render artifact immediately
                                } else if (jsonData.type === 'confidence' && typeof jsonData.score === 'number') {
                                    receivedConfidence = jsonData.score; // Store confidence score
                                } else if (jsonData.type === 'entity') {
                                    console.log("Received entity:", jsonData.data); // Log entity data (handle as needed)
                                } else if (jsonData.type === 'done') {
                                    console.log("Stream done signal received."); // End of stream marker
                                } else {
                                     console.warn("Received unknown stream data type:", jsonData.type, jsonData);
                                }
                            } catch (e) {
                                console.error("Stream parsing error:", e, "Line:", line);
                                // Decide how to handle parsing errors (e.g., skip line, show error)
                            }
                        }
                    }
                    // Ensure streaming indicator stays visible during processing
                    if (currentStreamingMessageElement && !currentStreamingMessageElement.classList.contains('streaming')) {
                        currentStreamingMessageElement.classList.add('streaming');
                    }
                } // End while loop

                removeStreamingIndicator(); // Remove indicator after loop finishes

                // --- Handle Notepad Edit Command ---
                // Process the full response text for notepad commands *before* finalizing the message bubble
                const cleanedResponseText = handleAINotepadEdit(fullResponseText);

                // --- Finalize Assistant Message Bubble ---
                if (currentStreamingMessageElement) {
                    // Update with the final, potentially cleaned text
                     if (typeof marked !== 'undefined') {
                         currentStreamingMessageElement.innerHTML = sanitizeHTML(marked.parse(cleanedResponseText));
                     } else {
                         currentStreamingMessageElement.textContent = cleanedResponseText; // Fallback
                     }


                    // Add citations if received
                    if (receivedCitations && receivedCitations.length > 0) {
                        const citationList = document.createElement('div');
                        citationList.className = 'citation-source-list';
                        let listHtml = '<h4>Sources:</h4><ul>';
                        receivedCitations.forEach((cite, index) => {
                            const citeNum = index + 1;
                            const regex = new RegExp(`\\[${citeNum}\\](?![\w-])`, 'g');
                            const safeTitle = sanitizeHTML(cite.title || cite.url);
                            const safeUrl = sanitizeHTML(cite.url);
                            currentStreamingMessageElement.innerHTML = currentStreamingMessageElement.innerHTML.replace(regex, `<span class="citation" title="${safeTitle}" data-url="${safeUrl}">[${citeNum}]</span>`);
                            listHtml += `<li>[${citeNum}] <a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeTitle}</a></li>`;
                        });
                        listHtml += '</ul>';
                        citationList.innerHTML = listHtml;
                        currentStreamingMessageElement.appendChild(citationList);
                    }

                    // Add confidence score if received
                    if (receivedConfidence !== null) {
                        const confidenceSpan = document.createElement('span');
                        confidenceSpan.className = 'confidence-score';
                        confidenceSpan.textContent = `(${(receivedConfidence * 100).toFixed(0)}%)`;
                        currentStreamingMessageElement.appendChild(document.createTextNode(' ')); // Add space
                        currentStreamingMessageElement.appendChild(confidenceSpan);
                    }

                    // Final syntax highlighting run on the complete, cleaned content
                    if (typeof hljs !== 'undefined') {
                        currentStreamingMessageElement.querySelectorAll('pre code').forEach((block) => {
                            hljs.highlightElement(block);
                            const pre = block.parentElement;
                            if (pre && pre.tagName === 'PRE' && !pre.querySelector('.copy-code-btn')) {
                                const copyBtn = document.createElement('button');
                                copyBtn.className = 'copy-code-btn';
                                copyBtn.textContent = 'Copy';
                                copyBtn.onclick = () => copyCodeHandler(block, copyBtn);
                                pre.appendChild(copyBtn);
                            }
                        });
                    }
                } else {
                     // If the element somehow got removed, add the final message anew
                     console.warn("Streaming element missing, adding final message directly.");
                     addMessage(cleanedResponseText, 'assistant', {
                         messageId: assistantMessageId,
                         isHtml: true, // Assume markdown was parsed
                         citations: receivedCitations,
                         confidence: receivedConfidence
                     });
                }

                // --- Add Final Assistant Response to History ---
                // Add to history only if there's text content OR artifacts were generated
                if (cleanedResponseText || receivedArtifacts.length > 0) {
                    currentConv.history.push({
                        role: 'assistant',
                        content: cleanedResponseText || "[Generated artifacts]", // Use placeholder if only artifacts
                        id: assistantMessageId,
                        citations: receivedCitations,
                        // Store artifact IDs or references in history
                        artifacts: receivedArtifacts.map(a => a.id || a.title || 'artifact'), // Store IDs if available
                        confidence: receivedConfidence
                    });
                }
                saveConversations(); // Save updated history and artifacts

            } catch (error) {
                removeStreamingIndicator(); // Ensure indicator is removed on error
                console.error('Error during API call:', error);
                if (error.name === 'AbortError') {
                    console.log('Fetch aborted by user.');
                    // Optionally remove the placeholder if the request was aborted quickly
                    if (currentStreamingMessageElement && fullResponseText.length < 10) {
                        currentStreamingMessageElement.remove();
                    } else if (currentStreamingMessageElement) {
                         // If some text was received before abort, leave it but remove streaming class
                         currentStreamingMessageElement.classList.remove('streaming');
                    }
                } else {
                    // Display error message in chat
                    addMessage(`Sorry, an error occurred: ${error.message}. Please try again.`, 'assistant', { messageId: generateId() });
                    // Remove the potentially incomplete streaming message element
                    if (currentStreamingMessageElement) {
                        currentStreamingMessageElement.remove();
                    }
                }
            } finally {
                // --- Cleanup ---
                isWaitingForResponse = false;
                updateButtonStates(); // Re-enable send button
                messageInput.focus(); // Focus input for next message
                currentAbortController = null; // Clear abort controller
                removeStreamingIndicator(); // Final check to remove indicator
                currentStreamingMessageElement = null; // Clear reference
            }
        }


        // --- Event Listeners ---

        // View Mode Toggle
        viewModeToggle.addEventListener('click', toggleViewMode);

        // Batch Processing Panel
        batchProcessingToggleBtn.addEventListener('click', toggleBatchPanel);
        closeBatchPanelBtn.addEventListener('click', toggleBatchPanel);
        startNewBatchBtn.addEventListener('click', () => {
            alert("Functionality to start a new batch job is not yet implemented.");
            // Future: Open a modal or form to configure and start a new batch job
        });

        // Settings Panel Tabs
        settingsTabs.forEach(tab => {
            tab.addEventListener('click', () => switchSettingsTab(tab.dataset.tab));
        });

        // Settings Controls - Update conversation state on change
        dataResidency.addEventListener('change', (e) => {
            currentDataResidency = e.target.value;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].dataResidency = currentDataResidency;
                saveConversations();
            }
        });
        medTermToggle.addEventListener('change', (e) => {
            isMedTermEnabled = e.target.checked;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].medTermEnabled = isMedTermEnabled;
                saveConversations();
            }
        });
        equipSpecToggle.addEventListener('change', (e) => {
            isEquipSpecEnabled = e.target.checked;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].equipSpecEnabled = isEquipSpecEnabled;
                saveConversations();
            }
        });
        ragToggle.addEventListener('change', (e) => {
            isRagEnabled = e.target.checked;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].ragEnabled = isRagEnabled;
                saveConversations();
            }
        });
        kbEndpoint.addEventListener('change', (e) => { // Use 'change' or 'blur' instead of 'input' for less frequent updates
            currentKbEndpoint = e.target.value;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].kbEndpoint = currentKbEndpoint;
                saveConversations();
            }
        });
        modelSelector.addEventListener('change', (e) => {
            selectedModel = e.target.value;
            activeModelDisplay.textContent = `Current: ${selectedModel}`;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].model = selectedModel;
                saveConversations();
            }
        });
        temperatureSlider.addEventListener('input', (e) => { // Update display continuously
            currentTemperature = parseFloat(e.target.value);
            temperatureValue.textContent = currentTemperature.toFixed(1);
        });
        temperatureSlider.addEventListener('change', () => { // Save only when user releases slider
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].temperature = currentTemperature;
                saveConversations();
            }
        });
        thinkingModeToggle.addEventListener('change', (e) => {
            isThinkingModeEnabled = e.target.checked;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].thinkingMode = isThinkingModeEnabled;
                saveConversations();
            }
        });
        webSearchToggle.addEventListener('change', (e) => {
            isWebSearchEnabled = e.target.checked;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].webSearch = isWebSearchEnabled;
                saveConversations();
            }
        });
        responseStyleOptions.forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    currentResponseStyle = this.value;
                    if (currentConversationId && conversations[currentConversationId]) {
                        conversations[currentConversationId].responseStyle = currentResponseStyle;
                        saveConversations();
                    }
                }
            });
        });


        // File Upload Options (update internal state)
        enableOcr.addEventListener('change', (e) => currentUploadOptions.ocr = e.target.checked);
        extractTables.addEventListener('change', (e) => currentUploadOptions.tables = e.target.checked);
        segmentDoc.addEventListener('change', (e) => currentUploadOptions.segment = e.target.checked);
        workflowSelect.addEventListener('change', (e) => currentUploadOptions.workflow = e.target.value);

        // Chat Input & Submission
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault(); // Prevent default form submission
            if (!sendButton.disabled) {
                sendMessageToLLM();
            }
        });
        messageInput.addEventListener('keydown', (e) => {
            // Send on Enter (but not Shift+Enter)
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent newline in textarea
                if (!sendButton.disabled) {
                    sendMessageToLLM();
                }
            }
            // Show templates on '/' only if input is empty or just '/'
            if (e.key === '/' && (messageInput.value.trim() === '' || messageInput.value.trim() === '/')) {
                 // Small delay to allow '/' to appear if needed for template filtering later
                 setTimeout(() => {
                     renderTemplatesPopup();
                     templatesPopup.classList.add('active');
                 }, 10);
            } else {
                 // Hide popup if typing something else
                 // templatesPopup.classList.remove('active'); // Maybe too aggressive?
            }
        });
        messageInput.addEventListener('input', autoResizeTextarea); // Resize on input

        // Sidebar Actions
        settingsBtn.addEventListener('click', () => settingsPanel.classList.add('active'));
        closeSettings.addEventListener('click', () => settingsPanel.classList.remove('active'));
        newChatBtn.addEventListener('click', () => {
            createNewConversation();
            // Optional: Collapse sidebar on mobile after creating new chat
            if (sidebar.classList.contains('expanded') && window.innerWidth < 768) {
                sidebar.classList.remove('expanded');
                collapseToggleBtn.innerHTML = '<span>&gt;</span>';
                collapseToggleBtn.title = "Expand Menu";
            }
        });
        collapseToggleBtn.addEventListener('click', () => {
            sidebar.classList.toggle('expanded');
            // Update button text/icon and title based on state
            const isExpanded = sidebar.classList.contains('expanded');
            collapseToggleBtn.innerHTML = isExpanded ? '<span>&lt;</span>' : '<span>&gt;</span>';
            collapseToggleBtn.title = isExpanded ? "Collapse Menu" : "Expand Menu";
        });

        // File Upload Modal
        uploadFileBtn.addEventListener('click', () => {
            resetFileUpload(); // Ensure modal is reset before showing
            fileUploadModal.classList.add('active');
        });
        closeFileUploadModal.addEventListener('click', () => fileUploadModal.classList.remove('active'));
        cancelUpload.addEventListener('click', () => {
            fileUploadModal.classList.remove('active');
            resetFileUpload(); // Also reset if cancelled
        });
        dropArea.addEventListener('click', () => fileInput.click()); // Trigger hidden file input
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        // Drag and Drop listeners
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault(); // Necessary to allow drop
            dropArea.classList.add('dragover');
        });
        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('dragover');
        });
        dropArea.addEventListener('drop', (e) => {
            e.preventDefault(); // Prevent browser from opening file
            dropArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files); // Handle dropped files
        });
        confirmUpload.addEventListener('click', () => {
            if (selectedFile) {
                fileUploadModal.classList.remove('active');
                // Don't call sendMessageToLLM directly here.
                // The file is now staged in `selectedFile`.
                // The user should type a message and click Send,
                // or sendMessageToLLM should be modified to handle file-only uploads.
                // For now, let's assume the user needs to click Send.
                // We can add a placeholder message indicating the file is ready.
                addFilePlaceholderMessage(selectedFile);
                updateButtonStates(); // Enable send button if message is empty but file is present
                messageInput.focus(); // Focus input for accompanying message
            }
        });


        // Conversation Management
        clearCurrentHistoryBtn.addEventListener('click', () => {
            if (!currentConversationId || !conversations[currentConversationId]) return;
            if (confirm(`Are you sure you want to clear all history for "${conversations[currentConversationId].name}"? This cannot be undone.`)) {
                conversations[currentConversationId].history = []; // Clear history array
                conversations[currentConversationId].artifacts = []; // Clear artifacts array
                conversations[currentConversationId].associatedDocument = null; // Clear associated document
                loadConversation(currentConversationId); // Reload to clear UI and add initial message
                saveConversations();
                settingsPanel.classList.remove('active'); // Close settings panel
            }
        });
        viewEditHistoryBtn.addEventListener('click', showHistoryEditModal);
        closeHistoryModal.addEventListener('click', () => historyEditModal.classList.remove('active'));
        cancelHistoryEdit.addEventListener('click', () => historyEditModal.classList.remove('active'));

        // Conversation Title Rename
        conversationTitle.addEventListener('click', () => {
            conversationTitle.style.display = 'none'; // Hide static title
            conversationTitleInput.style.display = 'inline-block'; // Show input
            conversationTitleInput.value = conversationTitle.textContent; // Ensure input has current value
            conversationTitleInput.focus();
            conversationTitleInput.select(); // Select text for easy editing
        });
        conversationTitleInput.addEventListener('blur', () => { // Save on blur (losing focus)
            const newName = conversationTitleInput.value.trim();
            if (currentConversationId) {
                renameConversation(currentConversationId, newName); // Handles empty name check
            }
            // Always revert display back
            conversationTitle.style.display = 'inline-block';
            conversationTitleInput.style.display = 'none';
            // Ensure static title reflects the final name (even if rename failed due to empty input)
            conversationTitle.textContent = conversations[currentConversationId]?.name || "Chat";
        });
        conversationTitleInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent potential form submission if nested
                conversationTitleInput.blur(); // Trigger blur to save
            } else if (e.key === 'Escape') {
                // Revert input value to original name and trigger blur to hide input
                conversationTitleInput.value = conversations[currentConversationId]?.name || "Chat";
                conversationTitleInput.blur();
            }
        });


        // Prompt Templates
        templateBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent document click listener from closing immediately
            renderTemplatesPopup(); // Re-render in case templates change
            templatesPopup.classList.toggle('active');
        });

        // Global Click Listener (for closing popups/modals)
        document.addEventListener('click', (event) => {
            // Close Settings Panel if click is outside
            if (settingsPanel.classList.contains('active') && !settingsPanel.contains(event.target) && !settingsBtn.contains(event.target)) {
                settingsPanel.classList.remove('active');
            }
            // Close Templates Popup if click is outside
            if (templatesPopup.classList.contains('active') && !templatesPopup.contains(event.target) && !templateBtn.contains(event.target)) {
                templatesPopup.classList.remove('active');
            }
            // Close History Edit Modal if click is outside the modal content
            if (historyEditModal.classList.contains('active') && !historyEditModal.querySelector('.modal-content').contains(event.target)) {
                historyEditModal.classList.remove('active');
            }
            // Close File Upload Modal if click is outside the modal content
            if (fileUploadModal.classList.contains('active') && !fileUploadModal.querySelector('.modal-content').contains(event.target)) {
                fileUploadModal.classList.remove('active');
                resetFileUpload(); // Reset if closed by clicking outside
            }
            // Note: Notepad does not close on outside click by design in the original code
        });

        // --- Notepad Event Listeners ---
        notepadToggleBtn.addEventListener('click', () => {
            notepadContainer.classList.toggle('visible');
            if (notepadContainer.classList.contains('visible')) {
                notepadContent.focus(); // Focus content area when opened
            }
        });
        notepadCollapseBtn.addEventListener('click', () => {
            notepadContainer.classList.remove('visible');
        });
        notepadClearBtn.addEventListener('click', () => {
            // Only confirm if there is actual content
            if (notepadContent.textContent.trim() === '') return;
            if (confirm('Are you sure you want to clear all notes in the notepad?')) {
                notepadContent.innerHTML = ''; // Clear content
                saveNotepadContent(); // Save the empty state
                updateNotepadStatus('Cleared');
            }
        });
        notepadSaveBtn.addEventListener('click', () => {
            saveNotepadContent();
            updateNotepadStatus('Saved');
        });
        notepadAskLLMBtn.addEventListener('click', () => {
            // Get plain text content for the prompt
            const noteText = notepadContent.textContent.trim();
            if (!noteText) {
                updateNotepadStatus('Notepad is empty');
                return;
            }
            // Construct the prompt for the LLM
            const prompt = `Please review, edit for clarity and organization, and potentially summarize the following notes. Format the output using basic HTML (paragraphs <p>, lists <ul><li>, bold <strong>). Respond ONLY with the edited notes enclosed in [NOTEPAD:BEGIN] and [NOTEPAD:END] tags.\n\nNotes:\n${noteText}`;

            // Place the prompt in the main chat input
            messageInput.value = prompt;
            updateNotepadStatus('Prompt ready in chat input');
            autoResizeTextarea(); // Adjust input height
            updateButtonStates(); // Enable send button
            messageInput.focus(); // Focus the main input

            // Optional: Close notepad after generating prompt
            // notepadContainer.classList.remove('visible');
        });

        // Auto-save notepad content after a delay on input
        let saveTimeout;
        notepadContent.addEventListener('input', () => {
            updateNotepadStatus('Editing...');
            clearTimeout(saveTimeout); // Reset timer on new input
            saveTimeout = setTimeout(() => {
                saveNotepadContent();
                updateNotepadStatus('Auto-saved');
            }, 1500); // Auto-save after 1.5 seconds of inactivity
        });

        // Handle '/note' command in main input
        messageInput.addEventListener('keyup', function(e) {
            // Check if input starts with '/note ' and has content after it
            if (this.value.trim().startsWith('/note ')) {
                const noteToAdd = this.value.trim().substring(6); // Get text after '/note '

                if (noteToAdd) { // Only add if there's actual text
                    // Ensure notepad is visible
                    if (!notepadContainer.classList.contains('visible')) {
                        notepadContainer.classList.add('visible');
                    }

                    // Append the note as a new paragraph to the notepad content
                    const p = document.createElement('p');
                    p.textContent = noteToAdd; // Use textContent to prevent HTML injection
                    notepadContent.appendChild(p);

                    // Add a line break after the paragraph for spacing (optional)
                    // notepadContent.appendChild(document.createElement('br'));

                    // Scroll to the bottom of the notepad
                    notepadContent.scrollTop = notepadContent.scrollHeight;

                    saveNotepadContent(); // Save the updated notepad
                    updateNotepadStatus('Note added from chat');

                    // Clear the main input field
                    this.value = '';
                    autoResizeTextarea();
                    updateButtonStates();

                    e.preventDefault(); // Prevent any default action for the keyup event
                }
            }
        });


        // --- Initialization ---
        function initializeApp() {
             console.log("Initializing Enterprise App Concept...");
             // 1. Load conversations (this includes selecting/creating one and loading its state)
             loadConversations();
             // 2. Initialize Notepad (loads content based on the active conversation)
             initializeNotepad();
             // 3. Update UI elements based on the loaded state
             updateSettingsUI(); // Reflects settings of the loaded conversation
             autoResizeTextarea(); // Initial size adjustment
             updateButtonStates(); // Set initial button states
             // 4. Set initial view mode (optional, default is 'chat')
             if (currentViewMode !== 'chat') {
                 // If default should be dashboard, toggle here, otherwise ensure chat view is set
                 mainContent.classList.remove('dashboard-view');
                 analysisDashboard.style.display = 'none';
                 inputContainer.style.display = 'block';
                 viewModeToggle.textContent = 'Dashboard View';
             }
             // 5. Configure external libraries if loaded
             if (typeof hljs !== 'undefined') {
                 hljs.configure({ ignoreUnescapedHTML: true }); // Configure highlight.js
             } else {
                 console.warn("highlight.js (hljs) not loaded.");
             }
             if (typeof marked === 'undefined') {
                 console.warn("marked.js not loaded. Markdown rendering will be basic.");
             }
              if (typeof DOMPurify === 'undefined') {
                 console.warn("DOMPurify not loaded. HTML sanitization will be basic/less secure.");
             }
             // 6. Set initial focus
             messageInput.focus();
             // 7. Example: Update notification count (replace with actual logic)
             updateNotificationCount(3); // Example static count
             console.log("App Initialized. Current Conv ID:", currentConversationId);
        }

        function updateNotificationCount(count) {
            const numCount = parseInt(count, 10);
            if (!isNaN(numCount) && numCount > 0) {
                notificationBadge.textContent = numCount; // Use textContent
                notificationBadge.style.display = 'flex'; // Use flex to center content vertically/horizontally if needed by CSS
            } else {
                notificationBadge.textContent = '0'; // Reset text content
                notificationBadge.style.display = 'none'; // Hide badge
            }
        }

        function renderTemplatesPopup() {
            templatesPopup.innerHTML = ''; // Clear previous items
            const promptTemplates = [
                { name: "Summarize Text", prompt: "Please summarize the following text:\n\n" },
                { name: "Explain Code", prompt: "Explain this code snippet:\n\n```\n[Your Code Here]\n```\n" },
                { name: "Translate to French", prompt: "Translate the following text to French:\n\n" },
                { name: "Brainstorm Ideas", prompt: "Brainstorm ideas for:\n\n" },
                { name: "Write Email", prompt: "Write a professional email about:\n\nSubject: [Subject]\n\nBody:\n" },
                { name: "Add to Notepad", prompt: "/note " } // Example for /note command
            ];

            promptTemplates.forEach(template => {
                const item = document.createElement('div');
                item.className = 'template-item';

                // Use textContent for safety, display first ~50 chars of prompt
                const promptPreview = template.prompt.replace(/\n/g, ' ').substring(0, 50);
                item.innerHTML = `<strong>${sanitizeHTML(template.name)}</strong> ${sanitizeHTML(promptPreview)}...`; // Sanitize parts

                item.onclick = () => {
                    messageInput.value = template.prompt; // Set input value
                    templatesPopup.classList.remove('active'); // Close popup
                    messageInput.focus(); // Focus input
                    autoResizeTextarea(); // Adjust height
                    updateButtonStates(); // Update send button state
                    // If it's the /note template, move cursor to end
                    if (template.prompt === "/note ") {
                        messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    }
                };
                templatesPopup.appendChild(item);
            });
        }


        // Start the application once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GCT Enterprise App Concept</title>
    <!-- 1. Link to your actual CSS file -->
    <link rel="stylesheet" href="style.css"> <!-- Make sure style.css exists and contains your styles -->

    <!-- 2. Include Highlight.js CSS (choose a theme) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <!-- Or link your own theme -->

    <style>
        /* Basic styles (should ideally be in style.css) */
        :root {
            --border-color: #ccc;
            --text-muted: #666;
            --bg-primary: #fff;
            --accent-primary: #007bff;
            --text-secondary: #333;
            --danger-color: #dc3545;
            /* Define other variables used */
        }

        body { font-family: sans-serif; margin: 0; display: flex; height: 100vh; overflow: hidden; }

        /* AI Edit Highlight Animation */
        .ai-edit-highlight {
            animation: highlight-fade 3s ease-out;
            background-color: rgba(255, 255, 0, 0.3); /* Initial highlight */
        }
        @keyframes highlight-fade {
            from { background-color: rgba(255, 255, 0, 0.5); }
            to { background-color: transparent; }
        }

        /* Sidebar */
        .sidebar { width: 250px; border-right: 1px solid var(--border-color); padding: 1rem; display: flex; flex-direction: column; height: 100%; background: #f8f9fa; transition: width 0.3s ease; flex-shrink: 0; }
        .sidebar:not(.expanded) { width: 60px; }
        .sidebar:not(.expanded) .sidebar-item-text,
        .sidebar:not(.expanded) .sidebar-section-title { display: none; }
        .sidebar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .sidebar-button { background: none; border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; width: 100%; margin-bottom: 0.5rem; text-align: left; white-space: nowrap; overflow: hidden; }
        .sidebar-button span:first-child { min-width: 20px; text-align: center; }
        .sidebar-item { background: none; border: none; padding: 0.5rem; cursor: pointer; display: flex; align-items: center; gap: 0.5rem; width: 100%; margin-bottom: 0.2rem; text-align: left; border-radius: 4px; white-space: nowrap; overflow: hidden; }
        .sidebar-item.active { background-color: #e9ecef; }
        .sidebar-section { margin-top: 1rem; }
        .sidebar-section-title { color: var(--text-muted); font-size: 0.8rem; margin-bottom: 0.5rem; text-transform: uppercase; }
        .badge { background-color: var(--danger-color); color: white; border-radius: 50%; padding: 2px 6px; font-size: 0.7rem; margin-left: 5px; }
        .sidebar-footer { margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--border-color); width: 100%; }

        /* Main Content */
        .main-content-wrapper { flex-grow: 1; display: flex; height: 100%; overflow: hidden; }
        .main-content { flex-grow: 1; display: flex; flex-direction: column; overflow-y: auto; }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 1rem; border-bottom: 1px solid var(--border-color); background: var(--bg-primary); flex-shrink: 0; }
        .header-left, .header-right { display: flex; align-items: center; gap: 1rem; }
        .app-title { font-size: 1.2rem; margin: 0; }
        .app-subtitle { font-size: 0.8rem; color: var(--text-muted); margin: 0; }
        #conversationTitle { font-size: 1.1rem; margin: 0; cursor: pointer; }
        #conversationTitleInput { display: none; font-size: 1.1rem; padding: 0.2rem; border: 1px solid var(--border-color); }
        #notification-badge { background-color: var(--danger-color); color: white; border-radius: 50%; padding: 2px 6px; font-size: 0.7rem; margin-left: -5px; display: none; /* Initially hidden */ align-items: center; justify-content: center; min-width: 18px; height: 18px; }

        /* Chat */
        .chat-container { flex-grow: 1; padding: 1rem; overflow-y: auto; display: flex; flex-direction: column; } /* Added flex column */
        .message { margin-bottom: 1rem; padding: 0.8rem 1rem; border-radius: 8px; max-width: 80%; position: relative; word-wrap: break-word; }
        .user-message { background-color: #e7f3ff; align-self: flex-end; margin-left: auto; }
        .assistant-message { background-color: #f1f1f1; align-self: flex-start; margin-right: auto; }
        .message.streaming::after { content: '‚ñç'; animation: blink 1s infinite; margin-left: 5px; display: inline-block; }
        @keyframes blink { 50% { opacity: 0; } }
        .delete-message-btn { position: absolute; top: 2px; right: 5px; background: none; border: none; color: #aaa; cursor: pointer; font-size: 1.2rem; display: none; line-height: 1; }
        .message:hover .delete-message-btn { display: block; }
        .message-actions { display: none; position: absolute; bottom: -15px; right: 10px; background: white; border: 1px solid #eee; border-radius: 4px; padding: 2px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); z-index: 5; } /* Added z-index */
        .message:hover .message-actions { display: flex; gap: 3px; }
        .message-action-btn { background: none; border: none; cursor: pointer; font-size: 0.8rem; padding: 3px; }
        pre { background-color: #eee; padding: 1rem; border-radius: 5px; overflow-x: auto; position: relative; margin: 0.5rem 0; }
        code { font-family: monospace; }
        .copy-code-btn { position: absolute; top: 5px; right: 5px; background: #ddd; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 0.8rem; opacity: 0.7; }
        .copy-code-btn:hover { opacity: 1; }
        .copy-code-btn.copied { background-color: #aeffae; }
        .citation { background-color: #d6eaff; padding: 1px 4px; border-radius: 3px; cursor: help; font-size: 0.8em; vertical-align: super; }
        .citation-source-list { font-size: 0.8rem; margin-top: 0.8rem; padding-top: 0.5rem; border-top: 1px dashed #ccc; color: var(--text-muted); }
        .citation-source-list h4 { margin: 0 0 0.3rem 0; font-size: 0.85rem; }
        .citation-source-list ul { margin: 0; padding-left: 1.2rem; }
        .confidence-score { font-size: 0.8rem; color: var(--text-muted); margin-left: 5px; }
        .file-placeholder { display: flex; align-items: center; gap: 0.5rem; background: #f0f0f0; padding: 0.5rem; border-radius: 4px; margin-top: 0.5rem; }

        /* Input */
        .input-container { padding: 1rem; border-top: 1px solid var(--border-color); background: var(--bg-primary); flex-shrink: 0; }
        .input-wrapper { display: flex; align-items: flex-end; border: 1px solid var(--border-color); border-radius: 8px; padding: 0.5rem; position: relative; }
        .input-actions { display: flex; align-items: center; margin-right: 0.5rem; }
        .input-action-button { background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0.3rem; color: #555; }
        #fileInput { display: none; }
        .message-input { flex-grow: 1; border: none; outline: none; resize: none; font-size: 1rem; padding: 0.5rem; max-height: 150px; overflow-y: auto; line-height: 1.4; }
        .send-button { background-color: var(--accent-primary); color: white; border: none; border-radius: 5px; padding: 0.6rem 1rem; cursor: pointer; margin-left: 0.5rem; }
        .send-button:disabled { background-color: #ccc; cursor: not-allowed; }
        .templates-popup { display: none; position: absolute; bottom: 100%; left: 0; background: white; border: 1px solid #ccc; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); max-height: 200px; overflow-y: auto; z-index: 10; min-width: 200px; margin-bottom: 5px; }
        .templates-popup.active { display: block; }
        .template-item { padding: 0.5rem 1rem; cursor: pointer; font-size: 0.9rem; }
        .template-item:hover { background-color: #f0f0f0; }
        .template-item strong { display: block; margin-bottom: 0.2rem; }

        /* Dashboard */
        .analysis-dashboard { display: none; flex-wrap: wrap; gap: 1rem; padding: 1rem; }
        .dashboard-section { border: 1px solid var(--border-color); border-radius: 8px; padding: 1rem; flex: 1 1 300px; background: var(--bg-primary); }
        .dashboard-section-title { margin-top: 0; color: var(--text-secondary); }
        #documentViewerPlaceholder, #entityHighlightPlaceholder, #timeSeriesChartPlaceholder, #anomalyVizPlaceholder, #predictiveVizPlaceholder { min-height: 150px; background: #f9f9f9; border: 1px dashed #ddd; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #999; border-radius: 4px; margin-bottom: 1rem; text-align: center; }
        #annotationToolbar { background: #eee; padding: 5px; border-radius: 4px; margin-bottom: 10px; }
        .tool-btn { background: white; border: 1px solid #ccc; border-radius: 3px; padding: 3px 6px; cursor: pointer; }
        .placeholder-text { color: var(--text-muted); font-style: italic; }

        /* Right Panel */
        .right-panel { width: 300px; border-left: 1px solid var(--border-color); padding: 1rem; background: #f8f9fa; height: 100%; overflow-y: auto; display: none; flex-shrink: 0; }
        .right-panel.visible { display: block; }
        .artifact { border: 1px solid #ddd; border-radius: 5px; margin-bottom: 1rem; background: white; }
        .artifact-header { display: flex; justify-content: space-between; padding: 0.5rem; background: #eee; border-bottom: 1px solid #ddd; font-size: 0.9rem; }
        .artifact-title { font-weight: bold; }
        .artifact-type { background: #ccc; color: #333; padding: 2px 5px; border-radius: 3px; font-size: 0.7rem; }
        .artifact-content { padding: 0.5rem; max-height: 200px; overflow-y: auto; }
        .artifact-content pre { background: #f0f0f0; padding: 0.5rem; }
        .artifact-content p { margin: 0; } /* Prevent default paragraph margins */

        /* Settings Panel */
        .settings-panel { position: fixed; top: 0; right: -450px; width: 400px; max-width: 90%; height: 100%; background: white; box-shadow: -2px 0 5px rgba(0,0,0,0.1); z-index: 100; transition: right 0.3s ease-in-out; display: flex; flex-direction: column; }
        .settings-panel.active { right: 0; }
        .settings-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .settings-title { margin: 0; font-size: 1.2rem; }
        .close-settings { background: none; border: none; font-size: 1.5rem; cursor: pointer; line-height: 1; }
        .settings-tabs { display: flex; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .settings-tab { flex-grow: 1; padding: 0.8rem 0.5rem; background: none; border: none; border-bottom: 2px solid transparent; cursor: pointer; text-align: center; font-size: 0.9rem; color: var(--text-muted); }
        .settings-tab.active { border-bottom-color: var(--accent-primary); color: var(--accent-primary); font-weight: bold; }
        .settings-content-wrapper { padding: 1rem; overflow-y: auto; flex-grow: 1; }
        .settings-content { display: none; }
        .settings-content.active { display: block; }
        .settings-section { margin-bottom: 1.5rem; }
        .settings-section-title { margin-bottom: 0.8rem; font-size: 1rem; color: var(--text-secondary); border-bottom: 1px solid #eee; padding-bottom: 0.3rem; }
        .settings-button { background-color: #eee; border: 1px solid #ccc; border-radius: 4px; padding: 0.5rem 1rem; cursor: pointer; margin-right: 0.5rem; margin-bottom: 0.5rem; font-size: 0.9rem; }
        .settings-button.primary { background-color: var(--accent-primary); color: white; border-color: var(--accent-primary); }
        .settings-button.danger { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }
        .settings-option { display: flex; align-items: center; margin-bottom: 0.5rem; font-size: 0.9rem; }
        .settings-option input[type="radio"], .settings-option input[type="checkbox"] { margin-right: 0.5rem; flex-shrink: 0; }
        .settings-option label { margin-left: 0.2rem; flex-grow: 1; }
        .settings-option select, .settings-option input[type="text"] { padding: 0.4rem; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; }
        .slider-container { display: flex; align-items: center; gap: 1rem; }
        .compliance-logos img { height: 30px; margin-right: 10px; opacity: 0.7; vertical-align: middle; } /* Added vertical-align */
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 120px; background-color: black; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -60px; opacity: 0; transition: opacity 0.3s; font-size: 0.8rem; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        /* File Upload Modal */
        .file-upload-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 101; }
        .file-upload-modal.active { display: flex; }
        .modal-content { background: white; padding: 2rem; border-radius: 8px; max-width: 500px; width: 90%; box-shadow: 0 5px 15px rgba(0,0,0,0.2); position: relative; display: flex; flex-direction: column; max-height: 90vh; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 1px solid #eee; padding-bottom: 1rem; flex-shrink: 0; }
        .modal-title { margin: 0; font-size: 1.3rem; }
        .close-modal { background: none; border: none; font-size: 1.8rem; cursor: pointer; line-height: 1; }
        .file-upload-area { border: 2px dashed #ccc; border-radius: 8px; padding: 2rem; text-align: center; margin-bottom: 1.5rem; cursor: pointer; flex-shrink: 0; }
        .file-upload-area.dragover { border-color: var(--accent-primary); background-color: #f0f7ff; }
        .file-upload-text { color: var(--text-muted); margin: 0; }
        .file-preview { max-width: 100%; max-height: 150px; margin-top: 1rem; border-radius: 4px; display: none; }
        .file-info { margin-top: 1rem; display: none; align-items: center; justify-content: center; gap: 0.5rem; }
        .upload-options { margin-bottom: 1.5rem; overflow-y: auto; padding-right: 0.5rem; /* Add padding for scrollbar */ }
        .upload-options h4 { margin-top: 0; margin-bottom: 0.8rem; font-size: 1rem; }
        .file-upload-buttons { display: flex; justify-content: flex-end; gap: 1rem; margin-top: auto; /* Push buttons to bottom */ padding-top: 1rem; border-top: 1px solid #eee; flex-shrink: 0; }
        .cancel-button, .upload-button { padding: 0.6rem 1.2rem; border-radius: 5px; cursor: pointer; font-size: 0.9rem; }
        .cancel-button { background: #eee; border: 1px solid #ccc; }
        .upload-button { background: var(--accent-primary); color: white; border: 1px solid var(--accent-primary); }
        .upload-button:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; }

        /* History Edit Modal */
        #historyEditModal .modal-content { max-width: 700px; max-height: 80vh; }
        #historyEditContent { flex-grow: 1; overflow-y: auto; border: 1px solid var(--border-color); padding: 1rem; border-radius: 8px; background: var(--bg-primary); }
        .history-item { margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px dashed var(--border-color); position: relative; }
        .history-item-role { display: block; margin-bottom: 0.3rem; font-weight: bold; }
        .history-item-content { white-space: pre-wrap; font-size: 0.9rem; margin-right: 70px; /* Space for button */ }
        .history-delete-btn { position: absolute; top: 0; right: 0; background: none; border: 1px solid var(--danger-color); color: var(--danger-color); padding: 0.2rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem; }

        /* Batch Processing Panel */
        .batch-processing-panel { position: fixed; bottom: 0; right: -450px; width: 400px; max-width: 90%; height: 40vh; background: white; box-shadow: 0 -2px 5px rgba(0,0,0,0.1); z-index: 90; transition: right 0.3s ease-in-out; display: flex; flex-direction: column; border-top: 1px solid var(--border-color); }
        .batch-processing-panel.visible { right: 0; }
        .batch-panel-header { display: flex; justify-content: space-between; align-items: center; padding: 0.8rem 1rem; border-bottom: 1px solid var(--border-color); background: #f8f9fa; flex-shrink: 0; }
        .batch-panel-title { margin: 0; font-size: 1rem; }
        .batch-panel-actions button { margin-left: 0.5rem; }
        .batch-queue-list { padding: 1rem; overflow-y: auto; flex-grow: 1; }
        .batch-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid #eee; font-size: 0.9rem; }
        .batch-item:last-child { border-bottom: none; }
        .batch-item-name { flex-grow: 1; margin-right: 1rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .batch-item-status-container { display: flex; align-items: center; flex-shrink: 0; }
        .batch-item-status { font-weight: bold; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem; }
        .batch-item-status.pending { color: #6c757d; background: #e9ecef; }
        .batch-item-status.processing { color: #007bff; background: #e7f3ff; }
        .batch-item-status.completed { color: #28a745; background: #eaf7ec; }
        .batch-item-status.failed { color: #dc3545; background: #fbebec; }
        .batch-item-progress { width: 100px; height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden; margin-left: 5px; }
        .batch-item-progress-bar { height: 100%; background: var(--accent-primary); transition: width 0.3s ease; }

        /* Notepad */
        .notepad-container { position: fixed; bottom: 75px; /* Adjusted for typical input height */ right: 20px; width: 300px; max-width: 80%; background: #fffff0; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.15); z-index: 95; display: none; flex-direction: column; max-height: 50vh; }
        .notepad-container.visible { display: flex; }
        .notepad-header { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.8rem; border-bottom: 1px solid #eee; background: #f8f8e8; flex-shrink: 0; }
        .notepad-title { margin: 0; font-size: 1rem; }
        .notepad-actions button { background: none; border: none; cursor: pointer; font-size: 1rem; color: #666; padding: 0.2rem; line-height: 1; }
        .notepad-content { flex-grow: 1; padding: 0.8rem; overflow-y: auto; font-size: 0.9rem; line-height: 1.4; min-height: 100px; outline: none; white-space: pre-wrap; /* Preserve whitespace */ }
        .notepad-content[contenteditable=true]:empty:before { content: attr(data-placeholder); color: #999; font-style: italic; position: absolute; /* Needed for placeholder */ }
        .notepad-footer { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0.8rem; border-top: 1px solid #eee; background: #f8f8e8; font-size: 0.8rem; flex-shrink: 0; }
        .notepad-status { color: #777; opacity: 0.7; transition: opacity 0.5s; }
        .notepad-buttons button { background: #eee; border: 1px solid #ccc; border-radius: 4px; padding: 0.3rem 0.6rem; cursor: pointer; font-size: 0.8rem; margin-left: 0.5rem; }

    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar expanded" id="sidebar"> <!-- Start expanded -->
         <div class="sidebar-header">
             <button class="sidebar-button" id="newChatBtn" title="New Chat"><span>+</span> <span class="sidebar-item-text">New Chat</span></button>
             <button class="sidebar-button" id="collapseToggleBtn" title="Collapse Menu"><span>&lt;</span></button>
        </div>
        <div id="conversationList">
            <!-- Conversation items will be added here by JS -->
        </div>
        <div class="sidebar-section">
            <div class="sidebar-section-title">Workflows</div>
            <button class="sidebar-button" id="approvalQueueBtn" title="Approval Queue"><span>&#128204;</span> <span class="sidebar-item-text">Approvals <span class="badge">3</span></span></button>
             <button class="sidebar-button" id="batchProcessingToggleBtn" title="Batch Processing"><span>&#128230;</span> <span class="sidebar-item-text">Batch Jobs</span></button>
        </div>
         <div class="sidebar-section">
             <div class="sidebar-section-title">Knowledge</div>
             <button class="sidebar-button" id="docLibraryBtn" title="Document Library"><span>&#128193;</span> <span class="sidebar-item-text">Doc Library</span></button>
         </div>
        <div class="sidebar-footer">
             <button class="sidebar-button" id="settingsBtn" title="Settings"><span>&#9881;</span> <span class="sidebar-item-text">Settings</span></button>
        </div>
    </div>

    <!-- Main Content Wrapper -->
    <div class="main-content-wrapper">
        <div class="main-content" id="mainContent">
            <!-- Header -->
            <header class="header">
                 <div class="header-left">
                    <div class="app-info">
                        <h1 class="app-title">GCT Enterprise App Concept</h1>
                        <p class="app-subtitle">Enterprise Analysis Platform</p>
                    </div>
                    <h2 id="conversationTitle" title="Click to rename">Analysis Session</h2>
                    <input type="text" id="conversationTitleInput" placeholder="Enter new title..." />
                </div>
                <div class="header-right">
                    <button id="viewModeToggle" title="Toggle Dashboard View">Dashboard View</button>
                    <button id="notificationsBtn" title="Notifications">
                        <span>&#128276;</span>
                        <span id="notification-badge">0</span>
                    </button>
                    <div id="userProfilePlaceholder">
                        <!-- Placeholder for user profile icon/menu -->
                        <span style="padding: 0.5rem; border: 1px solid #ccc; border-radius: 50%;">üë§</span>
                    </div>
                </div>
            </header>

            <!-- Chat Container -->
            <main class="chat-container" id="chatContainer">
                <!-- Messages will be added here by JS -->
            </main>

            <!-- Input Container -->
            <div class="input-container" id="inputContainer">
                 <div class="input-wrapper">
                    <div class="templates-popup" id="templatesPopup"></div>
                    <!-- Removed form tag, handling submit via JS -->
                    <div class="input-actions">
                        <button type="button" class="input-action-button" id="templateBtn" title="Prompt Templates"><span>&#128220;</span></button>
                        <button type="button" class="input-action-button" id="uploadFileBtn" title="Upload File"><span>&#128206;</span></button>
                        <button type="button" class="input-action-button" id="notepadToggleBtn" title="Toggle Notepad"><span>&#128221;</span></button>
                        <input type="file" id="fileInput" accept="image/*,application/pdf,.txt,.csv,.json,.md,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/dicom,.dcm">
                    </div>
                    <textarea class="message-input" id="messageInput" placeholder="Ask about the document or use /note ..." rows="1"></textarea>
                    <button type="button" class="send-button" id="sendButton" disabled>Send</button> <!-- Changed to type="button" -->
                </div>
            </div>

            <!-- Multimodal Analysis Dashboard (Initially Hidden) -->
            <div class="analysis-dashboard" id="analysisDashboard">
                 <div class="dashboard-section">
                    <h3 class="dashboard-section-title">Document Viewer</h3>
                    <div id="documentViewerPlaceholder">
                        <div id="annotationToolbar">
                            <button class="tool-btn" title="Select"> S </button>
                            <button class="tool-btn" title="Draw">‚úèÔ∏è</button>
                            <button class="tool-btn" title="Highlight"> H </button>
                            <button class="tool-btn" title="Text"> T </button>
                            <button class="tool-btn" title="Comment">üí¨</button>
                        </div>
                        <span>Document Preview Area</span>
                    </div>
                </div>
                 <div class="dashboard-section">
                     <h3 class="dashboard-section-title">Detected Entities & Analysis</h3>
                     <div id="entityHighlightPlaceholder">
                         <p>Measurements: <span style="background-color: rgba(255, 165, 0, 0.3); padding: 2px 4px; border-radius: 3px;">15.2mm</span> <span class="confidence-score">(98%)</span></p>
                         <p class="placeholder-text">Detected items will be listed here...</p>
                     </div>
                 </div>
                 <div class="dashboard-section">
                     <h3 class="dashboard-section-title">Advanced Analytics</h3>
                     <div id="timeSeriesChartPlaceholder">Time-Series Visualization</div>
                     <div id="anomalyVizPlaceholder">Anomaly Detection Visualization</div>
                     <div id="predictiveVizPlaceholder">Predictive Modeling Visualization</div>
                     <button class="settings-button" style="margin-top: 1rem; width: auto;">Compare with History</button>
                 </div>
            </div>
        </div>

        <!-- Right Panel (Artifacts / Details - Initially Hidden) -->
        <div class="right-panel" id="rightPanel">
             <h3 style="color: var(--text-muted); text-align: center; margin-bottom: 1rem;">Details & Artifacts</h3>
            <div class="artifact">
                <div class="artifact-header"><span class="artifact-title">Extracted Table</span><span class="artifact-type">CSV</span></div>
                <div class="artifact-content"><pre><code>ID,Value,Unit\n1,15.2,mm\n2,10.0,cm</code></pre></div>
            </div>
             <div class="settings-section" style="margin-top: 2rem;">
                 <h3 class="settings-section-title">Collaboration</h3>
                 <div class="placeholder-text">Comments and annotations appear here.</div>
                 <button class="settings-button primary">Share Findings</button>
                 <button class="settings-button">Export Report (PDF)</button>
             </div>
        </div>
    </div>

    <!-- Settings Panel (Initially Hidden) -->
    <div class="settings-panel" id="settingsPanel">
          <div class="settings-header">
             <h2 class="settings-title">Settings & Configuration</h2>
             <button class="close-settings" id="closeSettings">&times;</button>
         </div>
         <div class="settings-tabs">
             <button class="settings-tab active" data-tab="general">General</button>
             <button class="settings-tab" data-tab="model">Model</button>
             <button class="settings-tab" data-tab="security">Security</button>
             <button class="settings-tab" data-tab="workflows">Workflows</button>
             <button class="settings-tab" data-tab="integrations">Integrations</button>
             <button class="settings-tab" data-tab="knowledge">Knowledge</button>
         </div>
         <div class="settings-content-wrapper">
             <!-- General Settings Tab -->
             <div class="settings-content active" id="settings-tab-general">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Conversation</h3>
                     <button id="viewEditHistoryBtn" class="settings-button">View / Edit History</button>
                     <button id="clearCurrentHistoryBtn" class="settings-button danger">Clear Current Session History</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Response Style</h3>
                     <div class="settings-option"><input type="radio" id="professionalStyle" name="responseStyle" value="professional"><label for="professionalStyle">Professional</label></div>
                     <div class="settings-option"><input type="radio" id="conciseStyle" name="responseStyle" value="concise"><label for="conciseStyle">Concise</label></div>
                     <div class="settings-option"><input type="radio" id="normalStyle" name="responseStyle" value="normal" checked><label for="normalStyle">Normal</label></div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Advanced Modes</h3>
                     <div class="settings-option"><input type="checkbox" id="thinkingModeToggle"><label for="thinkingModeToggle">Enable Extended Reasoning</label></div>
                     <div class="settings-option"><input type="checkbox" id="webSearchToggle"><label for="webSearchToggle">Enable Web Search</label></div>
                 </div>
             </div>
             <!-- Model Settings Tab -->
             <div class="settings-content" id="settings-tab-model">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Model Selection</h3>
                     <div class="settings-option">
                         <select id="modelSelector">
                             <option value="llama3:8b">Llama 3 8B (Default)</option>
                             <option value="claude-3-sonnet">Claude 3 Sonnet</option>
                             <option value="gpt-4-turbo">GPT-4 Turbo</option>
                             <option value="domain-specific-med-v1">Domain: Medical v1</option>
                             <option value="domain-specific-eng-v2">Domain: Engineering v2</option>
                         </select>
                     </div>
                     <div id="activeModelDisplay" style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;">Current: llama3:8b</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Creativity (Temperature)</h3>
                     <div class="slider-container">
                         <input type="range" id="temperatureSlider" min="0" max="1.5" step="0.1" value="0.7">
                         <span id="temperatureValue">0.7</span>
                     </div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Model Management</h3>
                     <button class="settings-button">Manage Model Versions</button>
                     <button class="settings-button">Start Fine-tuning Job</button>
                     <button class="settings-button">View Performance Metrics</button>
                     <button class="settings-button">Configure A/B Test</button>
                     <div id="modelPerfDashboard" class="placeholder-text" style="margin-top: 1rem;">Model Performance Dashboard Area</div>
                 </div>
             </div>
             <!-- Security Settings Tab -->
             <div class="settings-content" id="settings-tab-security">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Compliance</h3>
                     <div class="compliance-logos">
                         <!-- TODO: Replace placeholder image paths -->
                         <span class="tooltip"><img src="placeholder-soc2.png" alt="SOC 2"><span class="tooltiptext">SOC 2 Compliant</span></span>
                         <span class="tooltip"><img src="placeholder-hipaa.png" alt="HIPAA"><span class="tooltiptext">HIPAA Compliant</span></span>
                         <span class="tooltip"><img src="placeholder-gdpr.png" alt="GDPR"><span class="tooltiptext">GDPR Compliant</span></span>
                     </div>
                     <div class="settings-option" style="margin-top: 1rem;">
                         <label for="dataResidency" style="margin-left: 0; margin-right: 0.5rem; flex-shrink: 0;">Data Residency:</label>
                         <select id="dataResidency">
                             <option value="us">United States</option>
                             <option value="eu">European Union</option>
                             <option value="global">Global Default</option>
                         </select>
                     </div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Access Control</h3>
                     <button class="settings-button">Manage Users & Roles (RBAC)</button>
                     <button class="settings-button">Manage Document Permissions</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Auditing</h3>
                     <button class="settings-button">View Audit Logs</button>
                 </div>
             </div>
             <!-- Workflows Tab -->
             <div class="settings-content" id="settings-tab-workflows">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Workflow Management</h3>
                     <button class="settings-button">Create / Edit Workflows</button>
                     <div class="placeholder-text" style="margin-top: 1rem;">Workflow Editor Area</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Approval Settings</h3>
                     <button class="settings-button">Configure Approval Queues</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Domain Specific Enhancements</h3>
                      <div class="settings-option"><input type="checkbox" id="medTermToggle"><label for="medTermToggle">Enable Medical Terminology Validation</label></div>
                      <div class="settings-option"><input type="checkbox" id="equipSpecToggle"><label for="equipSpecToggle">Enable Equipment-Specific Analysis</label></div>
                 </div>
             </div>
              <!-- Integrations Tab -->
             <div class="settings-content" id="settings-tab-integrations">
                 <div class="settings-section">
                     <h3 class="settings-section-title">EHR / EMR Systems</h3>
                     <button class="settings-button primary">Connect to EHR/EMR</button>
                     <div class="placeholder-text">List of connected systems...</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Enterprise Systems</h3>
                     <button class="settings-button">Connect to SAP</button>
                     <button class="settings-button">Connect to Salesforce</button>
                     <div class="placeholder-text">List of connected systems...</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">API Access</h3>
                     <button class="settings-button">Manage API Keys</button>
                 </div>
             </div>
              <!-- Knowledge Base Tab -->
             <div class="settings-content" id="settings-tab-knowledge">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Knowledge Base Connection</h3>
                     <div class="settings-option">
                         <label for="kbEndpoint" style="margin-left:0; margin-right: 0.5rem;">Endpoint:</label>
                         <input type="text" id="kbEndpoint" placeholder="Enter KB API endpoint...">
                     </div>
                      <div class="settings-option"><input type="checkbox" id="ragToggle"><label for="ragToggle">Enable Retrieval-Augmented Generation (RAG)</label></div>
                     <button class="settings-button primary" style="margin-top: 1rem;">Connect</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Document Library Settings</h3>
                     <button class="settings-button">Configure Semantic Search</button>
                 </div>
             </div>
         </div>
    </div>

    <!-- File Upload Modal (Initially Hidden) -->
    <div class="file-upload-modal" id="fileUploadModal">
         <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Upload & Process File</h2>
                <button class="close-modal" id="closeFileUploadModal">&times;</button>
            </div>
            <div class="file-upload-area" id="dropArea">
                <p class="file-upload-text">Drag & drop file or click to browse (PDF, DOCX, XLSX, DICOM, Images, Text...)</p>
                <img src="" alt="Image Preview" class="file-preview" id="imagePreview">
                <div class="file-info" id="fileInfoPreview">
                    <span style="font-size: 2rem;">üìÑ</span>
                    <span id="fileNamePreview"></span> (<span id="fileSizePreview"></span>)
                </div>
            </div>
            <div class="upload-options">
                <h4>Processing Options</h4>
                <div class="settings-option"><input type="checkbox" id="enableOcr" checked><label for="enableOcr">Enable OCR</label></div>
                <div class="settings-option"><input type="checkbox" id="extractTables" checked><label for="extractTables">Extract Tables</label></div>
                <div class="settings-option"><input type="checkbox" id="segmentDoc"><label for="segmentDoc">Segment Document Sections</label></div>
                <div class="settings-option">
                     <label for="workflowSelect" style="margin-left:0; margin-right: 0.5rem;">Apply Workflow:</label>
                     <select id="workflowSelect">
                         <option value="default">Default Analysis</option>
                         <option value="medical_report">Medical Report Review</option>
                         <option value="engineering_spec">Engineering Spec Check</option>
                         <option value="financial_audit">Financial Audit Assist</option>
                     </select>
                 </div>
            </div>
            <div class="file-upload-buttons">
                <button type="button" class="cancel-button" id="cancelUpload">Cancel</button>
                <button type="button" class="upload-button" id="confirmUpload" disabled>Confirm File</button> <!-- Changed text -->
            </div>
        </div>
    </div>

     <!-- History Edit Modal (Initially Hidden) -->
     <div class="file-upload-modal" id="historyEditModal" style="align-items: flex-start; padding-top: 5vh;">
          <div class="modal-content"> <!-- Added style overrides from original -->
             <div class="modal-header">
                 <h2 class="modal-title">Edit Conversation History</h2>
                 <button class="close-modal" id="closeHistoryModal">&times;</button>
             </div>
             <div id="historyEditContent">
                 <!-- History items will be added here by JS -->
             </div>
             <div style="margin-top: 1rem; text-align: right;">
                 <button type="button" class="cancel-button" id="cancelHistoryEdit">Close</button>
             </div>
         </div>
     </div>

     <!-- Batch Processing Panel (Initially Hidden) -->
     <div class="batch-processing-panel" id="batchProcessingPanel">
          <div class="batch-panel-header">
             <h3 class="batch-panel-title">Batch Processing Queue</h3>
             <div class="batch-panel-actions">
                 <button type="button" class="settings-button primary" id="startNewBatchBtn">Start New Batch</button>
                 <button type="button" class="settings-button" id="closeBatchPanelBtn">&times;</button>
             </div>
         </div>
         <div class="batch-queue-list" id="batchQueueList">
             <div class="placeholder-text">No active batch jobs.</div>
             <!-- Batch items will be added here by JS -->
         </div>
     </div>

    <!-- Notepad Container (Initially Hidden) -->
    <div class="notepad-container" id="notepadContainer">
         <div class="notepad-header">
            <h3 class="notepad-title">Notepad</h3>
            <div class="notepad-actions">
                <button type="button" class="notepad-action" id="notepadClearBtn" title="Clear notepad"><span>&#128465;</span></button>
                <button type="button" class="notepad-action" id="notepadCollapseBtn" title="Hide notepad"><span>&#10006;</span></button>
            </div>
        </div>
        <div class="notepad-content" id="notepadContent" contenteditable="true" spellcheck="true"></div>
        <div class="notepad-footer">
            <div class="notepad-status" id="notepadStatus">Ready</div>
            <div class="notepad-buttons">
                <button type="button" class="notepad-footer-btn" id="notepadSaveBtn">Save</button>
                <button type="button" class="notepad-footer-btn" id="notepadAskLLMBtn">Ask AI to edit</button>
            </div>
        </div>
    </div>

    <!-- JS Libraries (Place before your main script) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.10/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>


    <script>
        // --- DOM Elements ---
        // (Get references to all necessary elements using const)
        const sidebar = document.getElementById('sidebar');
        const collapseToggleBtn = document.getElementById('collapseToggleBtn');
        const approvalQueueBtn = document.getElementById('approvalQueueBtn');
        const batchProcessingToggleBtn = document.getElementById('batchProcessingToggleBtn');
        const docLibraryBtn = document.getElementById('docLibraryBtn');
        const mainContent = document.getElementById('mainContent');
        const chatContainer = document.getElementById('chatContainer');
        const inputContainer = document.getElementById('inputContainer');
        const analysisDashboard = document.getElementById('analysisDashboard');
        const viewModeToggle = document.getElementById('viewModeToggle');
        const notificationsBtn = document.getElementById('notificationsBtn');
        const notificationBadge = document.getElementById('notification-badge'); // Correct single declaration
        const rightPanel = document.getElementById('rightPanel');
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsTabs = document.querySelectorAll('.settings-tab');
        const settingsContents = document.querySelectorAll('.settings-content');
        const closeSettings = document.getElementById('closeSettings');
        const fileUploadModal = document.getElementById('fileUploadModal');
        const enableOcr = document.getElementById('enableOcr');
        const extractTables = document.getElementById('extractTables');
        const segmentDoc = document.getElementById('segmentDoc');
        const workflowSelect = document.getElementById('workflowSelect');
        const batchProcessingPanel = document.getElementById('batchProcessingPanel');
        const batchQueueList = document.getElementById('batchQueueList');
        const startNewBatchBtn = document.getElementById('startNewBatchBtn');
        const closeBatchPanelBtn = document.getElementById('closeBatchPanelBtn');
        // const chatForm = document.getElementById('chatForm'); // Removed form tag, no need for this
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const settingsBtn = document.getElementById('settingsBtn');
        const uploadFileBtn = document.getElementById('uploadFileBtn');
        const closeFileUploadModal = document.getElementById('closeFileUploadModal');
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('imagePreview');
        const fileInfoPreview = document.getElementById('fileInfoPreview');
        const fileNamePreview = document.getElementById('fileNamePreview');
        const fileSizePreview = document.getElementById('fileSizePreview');
        const confirmUpload = document.getElementById('confirmUpload');
        const cancelUpload = document.getElementById('cancelUpload');
        const clearCurrentHistoryBtn = document.getElementById('clearCurrentHistoryBtn');
        const viewEditHistoryBtn = document.getElementById('viewEditHistoryBtn');
        const historyEditModal = document.getElementById('historyEditModal');
        const closeHistoryModal = document.getElementById('closeHistoryModal');
        const cancelHistoryEdit = document.getElementById('cancelHistoryEdit');
        const historyEditContent = document.getElementById('historyEditContent');
        const newChatBtn = document.getElementById('newChatBtn');
        const responseStyleOptions = document.querySelectorAll('input[name="responseStyle"]');
        const conversationList = document.getElementById('conversationList');
        const conversationTitle = document.getElementById('conversationTitle');
        const conversationTitleInput = document.getElementById('conversationTitleInput');
        const modelSelector = document.getElementById('modelSelector');
        const activeModelDisplay = document.getElementById('activeModelDisplay');
        const temperatureSlider = document.getElementById('temperatureSlider');
        const temperatureValue = document.getElementById('temperatureValue');
        const thinkingModeToggle = document.getElementById('thinkingModeToggle');
        const webSearchToggle = document.getElementById('webSearchToggle');
        const templateBtn = document.getElementById('templateBtn');
        const templatesPopup = document.getElementById('templatesPopup');
        const dataResidency = document.getElementById('dataResidency');
        const medTermToggle = document.getElementById('medTermToggle');
        const equipSpecToggle = document.getElementById('equipSpecToggle');
        const ragToggle = document.getElementById('ragToggle');
        const kbEndpoint = document.getElementById('kbEndpoint');
        // Notepad DOM Elements
        const notepadContainer = document.getElementById('notepadContainer');
        const notepadContent = document.getElementById('notepadContent');
        const notepadToggleBtn = document.getElementById('notepadToggleBtn');
        const notepadCollapseBtn = document.getElementById('notepadCollapseBtn');
        const notepadClearBtn = document.getElementById('notepadClearBtn');
        const notepadStatus = document.getElementById('notepadStatus');
        const notepadSaveBtn = document.getElementById('notepadSaveBtn');
        const notepadAskLLMBtn = document.getElementById('notepadAskLLMBtn');

        // --- Global State ---
        let currentViewMode = 'chat';
        let isBatchPanelVisible = false;
        let conversations = {};
        let currentConversationId = null;
        let selectedFile = null; // Holds file info { name, type, size, base64 } when staged
        let currentResponseStyle = 'normal';
        let currentTemperature = 0.7;
        let isThinkingModeEnabled = false;
        let isWebSearchEnabled = false;
        let selectedModel = 'llama3:8b';
        let isWaitingForResponse = false;
        let currentStreamingMessageElement = null;
        let currentAbortController = null;
        let currentDataResidency = 'us';
        let isMedTermEnabled = false;
        let isEquipSpecEnabled = false;
        let isRagEnabled = false;
        let currentKbEndpoint = '';
        let currentUploadOptions = { ocr: true, tables: true, segment: false, workflow: 'default' };
        let notepadSaveTimeout; // For debouncing notepad saves

        // --- API Configuration ---
        const API_ENDPOINT = '/api/chat'; // Replace with your actual API endpoint
        const BATCH_API_ENDPOINT = '/api/batch'; // Replace if needed
        // const WORKFLOW_API_ENDPOINT = '/api/workflows'; // Replace if needed

        // --- Helper Functions ---
        function generateId() { return Date.now().toString(36) + Math.random().toString(36).substring(2); }
        function formatBytes(bytes, decimals = 2) { if (!+bytes) return '0 Bytes'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`; }
        function getFileIcon(mimeType = '') { if (mimeType.startsWith('image/')) return 'üñºÔ∏è'; if (mimeType.includes('pdf')) return 'üìÑ'; if (mimeType.includes('word')) return 'üìù'; if (mimeType.includes('sheet') || mimeType.includes('excel')) return 'üìä'; if (mimeType.startsWith('text/')) return 'üìú'; if (mimeType.includes('dicom')) return '‚öïÔ∏è'; return 'üìé'; }

        /**
         * Sanitizes HTML string to prevent XSS attacks.
         * Uses DOMPurify if available, otherwise provides a basic text conversion fallback.
         * @param {string} htmlString The HTML string to sanitize.
         * @returns {string} The sanitized HTML string.
         */
        function sanitizeHTML(htmlString) {
            if (typeof DOMPurify !== 'undefined') {
                // Configure DOMPurify to allow specific tags/attributes if needed,
                // but default configuration is generally good.
                return DOMPurify.sanitize(htmlString);
            } else {
                console.warn("DOMPurify not loaded. Using basic text conversion for sanitization (removes all HTML).");
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlString;
                return tempDiv.textContent || tempDiv.innerText || "";
            }
        }

        /**
         * Parses Markdown text to HTML using marked.js, then sanitizes the output.
         * Returns plain text if marked.js is not available.
         * @param {string} markdownText The Markdown text to parse.
         * @returns {string} Sanitized HTML string or plain text.
         */
        function parseAndSanitizeMarkdown(markdownText) {
            if (typeof marked !== 'undefined') {
                const rawHtml = marked.parse(markdownText);
                return sanitizeHTML(rawHtml); // Sanitize the HTML output of marked
            } else {
                console.warn("marked.js not loaded. Displaying Markdown as plain text.");
                // Basic fallback: escape HTML and replace newlines
                const tempDiv = document.createElement('div');
                tempDiv.textContent = markdownText;
                return tempDiv.innerHTML.replace(/\n/g, '<br>');
            }
        }

        /**
         * Adds a message bubble to the chat container.
         * @param {string} text The message content (plain text or Markdown/HTML).
         * @param {'user' | 'assistant'} role The role of the message sender.
         * @param {object} options Additional options.
         * @param {boolean} [options.isHtml=false] Whether the text is already HTML (skips Markdown parsing).
         * @param {string} [options.messageId] Specific ID for the message.
         * @param {Array|null} [options.citations] Array of citation objects.
         * @param {number|null} [options.confidence] Confidence score (0-1).
         * @returns {HTMLElement} The created message div element.
         */
        function addMessage(text, role, options = {}) {
            const { isHtml = false, messageId = generateId(), citations = null, confidence = null } = options;
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', `${role}-message`);
            messageDiv.dataset.messageId = messageId;

            let contentHtml = '';
            if (role === 'assistant') {
                // Assistant messages are assumed to be Markdown unless isHtml is true
                contentHtml = isHtml ? sanitizeHTML(text) : parseAndSanitizeMarkdown(text);
            } else { // User messages are treated as plain text
                // Escape HTML characters for plain text to prevent XSS
                const tempDiv = document.createElement('div');
                tempDiv.textContent = text;
                let escapedText = tempDiv.innerHTML;

                // Find and link URLs after escaping
                const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
                contentHtml = escapedText.replace(urlRegex, url => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);
                contentHtml = contentHtml.replace(/\n/g, '<br>'); // Replace newlines with <br>
            }

            // Set the sanitized/parsed content
            messageDiv.innerHTML = contentHtml;

            // --- Citations (Append after main content is set) ---
            if (citations && citations.length > 0) {
                const citationList = document.createElement('div');
                citationList.className = 'citation-source-list';
                let listHtml = '<h4>Sources:</h4><ul>';
                citations.forEach((cite, index) => {
                    const citeNum = index + 1;
                    const placeholder = `[${citeNum}]`;
                    // Use textContent to find placeholders safely, then replace in innerHTML
                    const regex = new RegExp(`\\[${citeNum}\\](?![\w-])`, 'g'); // Match [N] not followed by word chars
                    // Sanitize title/url before putting into attributes/links
                    const safeTitle = sanitizeHTML(cite.title || cite.url);
                    const safeUrl = sanitizeHTML(cite.url); // Basic sanitization for URL attribute
                    // Replace placeholder in the already set innerHTML
                    messageDiv.innerHTML = messageDiv.innerHTML.replace(regex, `<span class="citation" title="${safeTitle}" data-url="${safeUrl}">[${citeNum}]</span>`);
                    // Build the list item HTML
                    listHtml += `<li>[${citeNum}] <a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeTitle}</a></li>`;
                });
                listHtml += '</ul>';
                // Append the citation list HTML (already constructed with safe content)
                citationList.innerHTML = listHtml;
                messageDiv.appendChild(citationList);
            }

            // --- Confidence Score (Append after citations) ---
            if (role === 'assistant' && confidence !== null && typeof confidence === 'number') {
                 const confidenceSpan = document.createElement('span');
                 confidenceSpan.className = 'confidence-score';
                 confidenceSpan.textContent = `(${(confidence * 100).toFixed(0)}%)`;
                 // Append safely after existing content
                 messageDiv.appendChild(document.createTextNode(' ')); // Add space before
                 messageDiv.appendChild(confidenceSpan);
            }

            // --- Action Buttons ---
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-message-btn';
            deleteBtn.innerHTML = '&times;'; // Safe HTML entity
            deleteBtn.title = 'Delete message';
            deleteBtn.type = 'button'; // Good practice for buttons not submitting forms
            deleteBtn.onclick = () => deleteMessageHandler(messageId);
            messageDiv.appendChild(deleteBtn);

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            // Use textContent for button text if possible, or safe innerHTML
            actionsDiv.innerHTML = `
                <button type="button" class="message-action-btn" title="Add Comment">üí¨</button>
                <button type="button" class="message-action-btn" title="Send to Approval">‚úîÔ∏è</button>
                <button type="button" class="message-action-btn" title="Copy">üìã</button>`;
            messageDiv.appendChild(actionsDiv);

            chatContainer.appendChild(messageDiv);

            // --- Syntax Highlighting (Run after appending and setting innerHTML) ---
            highlightCodeInElement(messageDiv);

            // Scroll to bottom
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
            return messageDiv;
        }

        /**
         * Handles copying code from a code block.
         * @param {HTMLElement} block The <code> element.
         * @param {HTMLButtonElement} button The copy button.
         */
        function copyCodeHandler(block, button) {
            navigator.clipboard.writeText(block.textContent || '')
                .then(() => {
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                })
                .catch(err => {
                    console.error('Failed to copy code: ', err);
                    button.textContent = 'Error';
                    setTimeout(() => { button.textContent = 'Copy'; }, 2000);
                });
        }

        /**
         * Finds and highlights code blocks within a given element, adding copy buttons.
         * @param {HTMLElement} element The parent element to search within.
         */
        function highlightCodeInElement(element) {
            if (typeof hljs !== 'undefined') {
                element.querySelectorAll('pre code:not(.hljs)').forEach((block) => {
                    hljs.highlightElement(block);
                    const pre = block.parentElement;
                    // Add copy button only if it's a <pre> and doesn't have one yet
                    if (pre && pre.tagName === 'PRE' && !pre.querySelector('.copy-code-btn')) {
                        const copyBtn = document.createElement('button');
                        copyBtn.type = 'button';
                        copyBtn.className = 'copy-code-btn';
                        copyBtn.textContent = 'Copy';
                        copyBtn.onclick = () => copyCodeHandler(block, copyBtn);
                        pre.appendChild(copyBtn);
                    }
                });
            } else {
                // console.warn("highlight.js (hljs) not loaded. Skipping syntax highlighting.");
            }
        }

        /**
         * Adds a placeholder message indicating a file is ready to be sent.
         * @param {object} fileInfo File info object { name, type, size, base64 }.
         */
        function addFilePlaceholderMessage(fileInfo) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'user-message'); // It's a user action
            messageDiv.dataset.messageId = generateId(); // Temporary ID for the placeholder

            const icon = getFileIcon(fileInfo.type);
            let fileHtml = '';

            // Sanitize file name and type before displaying
            const safeFileName = sanitizeHTML(fileInfo.name);
            // const safeFileType = sanitizeHTML(fileInfo.type); // Type not displayed directly

            if (fileInfo.type.startsWith('image/')) {
                // Base64 source is generally safe if from FileReader, but alt text needs sanitizing.
                fileHtml = `<img src="${fileInfo.base64}" alt="${safeFileName}" style="max-width: 200px; max-height: 150px; border-radius: 0.5rem; margin-top: 0.5rem; display: block;">`;
            } else {
                fileHtml = `<div class="file-placeholder"><span>${icon}</span><span>${safeFileName} (${formatBytes(fileInfo.size)})</span></div>`;
            }

            // Construct the message content safely
            messageDiv.innerHTML = `File ready: ${fileHtml}`; // Insert the generated HTML

            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'delete-message-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.title = 'Remove file attachment';
            deleteBtn.onclick = () => {
                selectedFile = null; // Clear the staged file
                messageDiv.remove();
                updateButtonStates();
            };
            messageDiv.appendChild(deleteBtn);

            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
        }

        /**
         * Removes the streaming indicator from the current message and runs final highlighting.
         */
        function removeStreamingIndicator() {
            if (currentStreamingMessageElement) {
                currentStreamingMessageElement.classList.remove('streaming');
                // Run final highlighting on the completed message
                highlightCodeInElement(currentStreamingMessageElement);
                currentStreamingMessageElement = null;
            }
            // Remove separate typing indicator if used (not currently implemented)
            // const typingIndicator = chatContainer.querySelector('.typing-indicator');
            // if (typingIndicator) typingIndicator.remove();
        }

        /**
         * Resets the file upload modal UI and state.
         */
        function resetFileUpload() {
            fileInput.value = ''; // Clear the file input element
            imagePreview.src = '';
            imagePreview.style.display = 'none';
            imagePreview.alt = '';
            fileInfoPreview.style.display = 'none';
            fileNamePreview.textContent = '';
            fileSizePreview.textContent = '';
            // selectedFile = null; // Don't clear selectedFile here, it's cleared after sending or cancelling
            confirmUpload.disabled = true;
            dropArea.classList.remove('dragover');
            // Reset options checkboxes/selects
            enableOcr.checked = true;
            extractTables.checked = true;
            segmentDoc.checked = false;
            workflowSelect.value = 'default';
            // Reset internal options state
            currentUploadOptions = { ocr: true, tables: true, segment: false, workflow: 'default' };
        }

        /**
         * Handles file selection from input or drag/drop. Reads the file as Base64.
         * @param {FileList} files List of files selected/dropped.
         */
        function handleFiles(files) {
            if (!files || files.length === 0) {
                return;
            }
            const file = files[0];
            // Optional: Add checks for file size or type here before reading
            // const maxSize = 10 * 1024 * 1024; // 10 MB limit example
            // if (file.size > maxSize) {
            //     alert(`File is too large. Maximum size is ${formatBytes(maxSize)}.`);
            //     resetFileUpload();
            //     return;
            // }

            const reader = new FileReader();

            reader.onload = function(e) {
                const base64Data = e.target.result;
                // Store file info temporarily to be staged on confirmation
                const fileInfo = {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    base64: base64Data // The base64 string itself
                };

                // Update preview in modal
                if (fileInfo.type.startsWith('image/')) {
                    imagePreview.src = base64Data;
                    imagePreview.alt = sanitizeHTML(fileInfo.name); // Sanitize alt text
                    imagePreview.style.display = 'block';
                    fileInfoPreview.style.display = 'none';
                } else {
                    imagePreview.style.display = 'none';
                    imagePreview.src = '';
                    imagePreview.alt = '';
                    fileNamePreview.textContent = fileInfo.name; // textContent is safe
                    fileSizePreview.textContent = formatBytes(fileInfo.size);
                    fileInfoPreview.style.display = 'flex'; // Use flex for alignment
                }
                confirmUpload.disabled = false; // Enable confirm button
                confirmUpload.dataset.fileInfo = JSON.stringify(fileInfo); // Store info on button temporarily
            };

            reader.onerror = function(e) {
                console.error("File reading error:", e);
                alert("Error reading file.");
                resetFileUpload(); // Reset UI on error
            };

            reader.readAsDataURL(file); // Read the file as Base64
        }

        /**
         * Updates the enabled/disabled state of the send button.
         */
        function updateButtonStates() {
            const messageText = messageInput.value.trim();
            // Disable if waiting for response OR if message is empty AND no file is staged
            sendButton.disabled = isWaitingForResponse || (messageText.length === 0 && !selectedFile);
        }

        /**
         * Auto-resizes the message input textarea based on content.
         */
        function autoResizeTextarea() {
            messageInput.style.height = 'auto'; // Temporarily shrink
            const scrollHeight = messageInput.scrollHeight;
            const computedStyle = window.getComputedStyle(messageInput);
            const maxHeight = parseInt(computedStyle.maxHeight, 10) || 150; // Use defined max-height or default

            if (scrollHeight > maxHeight) {
                messageInput.style.height = maxHeight + 'px';
                messageInput.style.overflowY = 'auto';
            } else {
                // Use scrollHeight directly is common practice and usually works well
                messageInput.style.height = scrollHeight + 'px';
                messageInput.style.overflowY = 'hidden';
            }
            updateButtonStates(); // Update button state whenever text changes
        }

        /**
         * Loads conversations from localStorage.
         */
        function loadConversations() {
            let storedConvs = null;
            try {
                storedConvs = localStorage.getItem('gctEnterpriseConversations'); // Use a specific key
                if (storedConvs) {
                    conversations = JSON.parse(storedConvs);
                    // Basic validation
                    if (typeof conversations !== 'object' || conversations === null) {
                        console.warn("Invalid conversation data in localStorage. Resetting.");
                        conversations = {};
                    }
                    // Optional: Validate structure of individual conversations
                } else {
                    conversations = {};
                }
            } catch (e) {
                console.error("Error parsing conversations from localStorage:", e);
                conversations = {}; // Reset on error
            }

            const lastConvId = localStorage.getItem('gctEnterpriseLastConversationId');
            let idToLoad = null;

            if (lastConvId && conversations[lastConvId]) {
                idToLoad = lastConvId;
            } else if (Object.keys(conversations).length > 0) {
                // Find the most recent valid conversation if lastConvId is invalid/missing
                 const sortedIds = Object.keys(conversations).sort((a, b) =>
                    new Date(conversations[b]?.createdAt || 0) - new Date(conversations[a]?.createdAt || 0)
                 );
                 idToLoad = sortedIds[0] || null;
                 if (idToLoad) console.log("Last conversation ID invalid/missing, loading most recent:", idToLoad);
            }

            renderConversationList(); // Render the list before loading

            if (idToLoad) {
                 loadConversation(idToLoad);
            } else {
                 console.log("No valid conversations found, creating a new one.");
                 createNewConversation(); // Creates and loads a new one
            }
        }

        /**
         * Saves conversations and the last active ID to localStorage.
         */
        function saveConversations() {
            try {
                localStorage.setItem('gctEnterpriseConversations', JSON.stringify(conversations));
                if (currentConversationId) {
                    localStorage.setItem('gctEnterpriseLastConversationId', currentConversationId);
                } else {
                    localStorage.removeItem('gctEnterpriseLastConversationId');
                }
            } catch (e) {
                console.error("Error saving conversations to localStorage:", e);
                alert("Could not save conversation history. Storage might be full or unavailable.");
            }
        }

        /**
         * Creates a new conversation object and optionally loads it.
         * @param {boolean} [setActive=true] Whether to make the new conversation active.
         * @returns {string} The ID of the newly created conversation.
         */
        function createNewConversation(setActive = true) {
            const newId = generateId();
            const timestamp = new Date();
            // More robust default name
            const defaultName = `Analysis ${timestamp.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })} ${timestamp.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;

            // Use current global state as defaults for the new conversation
            conversations[newId] = {
                id: newId,
                name: defaultName,
                history: [], // Start empty
                model: selectedModel, // Use current global setting
                temperature: currentTemperature,
                thinkingMode: isThinkingModeEnabled,
                webSearch: isWebSearchEnabled,
                responseStyle: currentResponseStyle,
                dataResidency: currentDataResidency,
                medTermEnabled: isMedTermEnabled,
                equipSpecEnabled: isEquipSpecEnabled,
                ragEnabled: isRagEnabled,
                kbEndpoint: currentKbEndpoint,
                createdAt: timestamp.toISOString(),
                associatedDocument: null,
                notepadContent: '', // Initialize notepad content
                artifacts: [] // Initialize artifacts
            };

            renderConversationList(); // Update list display first

            if (setActive) {
                currentConversationId = newId;
                // Update UI directly for a new conversation, don't call loadConversation
                chatContainer.innerHTML = ''; // Clear chat area
                const initialMsgId = generateId();
                addMessage('Hello! How can I help you today?', 'assistant', { messageId: initialMsgId });
                // Add initial message to history *immediately*
                conversations[newId].history.push({ role: 'assistant', content: 'Hello! How can I help you today?', id: initialMsgId });

                conversationTitle.textContent = defaultName;
                conversationTitleInput.value = defaultName;
                conversationTitle.style.display = 'inline-block'; // Ensure static title is visible
                conversationTitleInput.style.display = 'none'; // Ensure input is hidden

                resetFileUpload(); // Clear file staging/preview
                selectedFile = null; // Ensure no file is staged
                messageInput.value = '';
                autoResizeTextarea();
                updateSettingsUI(); // Reflect the defaults in the settings panel
                updateButtonStates();
                rightPanel.innerHTML = '<h3 style="color: var(--text-muted); text-align: center; margin-bottom: 1rem;">Details & Artifacts</h3>'; // Reset right panel
                rightPanel.classList.remove('visible');
                loadNotepadContent(); // Load/clear notepad for the new conversation
                highlightActiveConversation(); // Highlight the new one in the list
                saveConversations(); // Save the new state including the initial message
            } else {
                saveConversations(); // Save even if not activating immediately
            }
            return newId;
        }

        /**
         * Loads and displays the specified conversation.
         * @param {string} id The ID of the conversation to load.
         */
        function loadConversation(id) {
            if (!conversations[id]) {
                console.error("Conversation not found:", id);
                // Attempt to load the first available conversation or create a new one
                const availableIds = Object.keys(conversations);
                if (availableIds.length > 0) {
                    const fallbackId = availableIds.sort((a, b) => new Date(conversations[b]?.createdAt || 0) - new Date(conversations[a]?.createdAt || 0))[0];
                    console.warn(`Falling back to conversation: ${fallbackId}`);
                    loadConversation(fallbackId); // Recursive call with fallback ID
                } else {
                    console.warn("No conversations available. Creating a new one.");
                    createNewConversation(); // Creates and loads a new one
                }
                return; // Exit the current failed load attempt
            }

            console.log("Loading conversation:", id);
            currentConversationId = id;
            const conv = conversations[id];

            // --- Update Global State from Loaded Conversation ---
            // Use nullish coalescing (??) for defaults to handle 0 or false values correctly
            selectedModel = conv.model ?? 'llama3:8b';
            currentTemperature = conv.temperature ?? 0.7;
            isThinkingModeEnabled = conv.thinkingMode ?? false;
            isWebSearchEnabled = conv.webSearch ?? false;
            currentResponseStyle = conv.responseStyle ?? 'normal';
            currentDataResidency = conv.dataResidency ?? 'us';
            isMedTermEnabled = conv.medTermEnabled ?? false;
            isEquipSpecEnabled = conv.equipSpecEnabled ?? false;
            isRagEnabled = conv.ragEnabled ?? false;
            currentKbEndpoint = conv.kbEndpoint ?? '';

            // --- Update UI Elements ---
            updateSettingsUI(); // Reflect loaded settings in the panel
            conversationTitle.textContent = conv.name;
            conversationTitleInput.value = conv.name;
            conversationTitle.style.display = 'inline-block'; // Ensure static title is visible
            conversationTitleInput.style.display = 'none'; // Ensure input is hidden

            // --- Render Chat History ---
            chatContainer.innerHTML = ''; // Clear previous messages
            if (conv.history && conv.history.length > 0) {
                conv.history.forEach(msg => {
                    // Basic validation before adding
                    if (msg && typeof msg.content === 'string' && typeof msg.role === 'string') {
                         addMessage(msg.content, msg.role, {
                             messageId: msg.id || generateId(), // Ensure ID exists
                             isHtml: msg.role === 'assistant', // Assume assistant content might be HTML/Markdown
                             citations: msg.citations,
                             confidence: msg.confidence
                         });
                    } else {
                        console.warn("Skipping invalid message in history:", msg);
                    }
                });
            } else {
                // If history is empty (e.g., after clearing), add the initial greeting
                const initialMsgId = generateId();
                addMessage('Hello! How can I help you today?', 'assistant', { messageId: initialMsgId });
                // Add this greeting to the history array if it's missing
                conv.history = [{ role: 'assistant', content: 'Hello! How can I help you today?', id: initialMsgId }];
                // Note: saveConversations() will be called later
            }

             // --- Update Dashboard View Placeholder ---
             const docViewer = document.getElementById('documentViewerPlaceholder');
             if (currentViewMode === 'dashboard' && docViewer) {
                 if (conv.associatedDocument) {
                     docViewer.innerHTML = `<span>Loading ${sanitizeHTML(conv.associatedDocument.name)}...</span>`; // Sanitize name
                 } else {
                     docViewer.innerHTML = `<span>No document loaded. Upload one.</span>`;
                 }
             }

            // --- Render Artifacts ---
            rightPanel.innerHTML = '<h3 style="color: var(--text-muted); text-align: center; margin-bottom: 1rem;">Details & Artifacts</h3>'; // Clear previous artifacts
            rightPanel.classList.remove('visible'); // Hide initially
            if (conv.artifacts && conv.artifacts.length > 0) {
                conv.artifacts.forEach(renderArtifact); // This will make panel visible if artifacts exist
            }

            // --- Reset Input & State ---
            resetFileUpload(); // Clear file staging/preview
            selectedFile = null; // Ensure no file is staged
            messageInput.value = '';
            autoResizeTextarea();
            updateButtonStates();
            highlightActiveConversation(); // Ensure correct item is highlighted in the list
            loadNotepadContent(); // Load notepad content specific to this conversation

            // --- Save (to update last loaded ID and potentially the added initial message) ---
            saveConversations();
        }

        /**
         * Renders the list of conversations in the sidebar.
         */
        function renderConversationList() {
            conversationList.innerHTML = ''; // Clear existing list
            // Sort by creation date, newest first
            const sortedIds = Object.keys(conversations).sort((a, b) => {
                // Handle potentially missing createdAt property
                const dateA = new Date(conversations[a]?.createdAt || 0);
                const dateB = new Date(conversations[b]?.createdAt || 0);
                return dateB - dateA; // Descending order
            });

            sortedIds.forEach(id => {
                const conv = conversations[id];
                if (!conv) return; // Skip if conversation data is somehow missing

                const item = document.createElement('button');
                item.type = 'button';
                item.className = 'sidebar-item';
                item.dataset.convId = id;
                item.title = conv.name; // Tooltip

                // Use textContent for safety
                const iconSpan = document.createElement('span');
                iconSpan.innerHTML = '&#128172;'; // Chat bubble icon

                const textSpan = document.createElement('span');
                textSpan.className = 'sidebar-item-text';
                textSpan.textContent = conv.name; // Use textContent for the name

                item.appendChild(iconSpan);
                item.appendChild(textSpan);

                item.onclick = () => {
                    if (id !== currentConversationId) { // Avoid reloading if already active
                        loadConversation(id);
                    }
                };

                // Add context menu for delete
                item.oncontextmenu = (e) => {
                    e.preventDefault();
                    // Add a visual cue or custom context menu here if desired
                    if (confirm(`Delete conversation "${sanitizeHTML(conv.name)}"?`)) { // Sanitize name in confirm dialog
                        deleteConversation(id);
                    }
                };

                conversationList.appendChild(item);
            });

            highlightActiveConversation(); // Highlight the currently active one
        }

        /**
         * Highlights the active conversation in the sidebar list.
         */
        function highlightActiveConversation() {
            document.querySelectorAll('.sidebar-item').forEach(item => {
                item.classList.toggle('active', item.dataset.convId === currentConversationId);
            });
        }

        /**
         * Renames a conversation.
         * @param {string} id The ID of the conversation.
         * @param {string} newName The new name.
         */
        function renameConversation(id, newName) {
            const trimmedName = newName.trim();
            if (conversations[id] && trimmedName) {
                conversations[id].name = trimmedName;
                saveConversations();
                renderConversationList(); // Update the list display
                // If renaming the current conversation, update the title display
                if (id === currentConversationId) {
                    conversationTitle.textContent = trimmedName;
                    conversationTitleInput.value = trimmedName; // Sync input value too
                }
                console.log(`Renamed conversation ${id} to "${trimmedName}"`);
            } else if (id === currentConversationId) {
                 // If new name is empty, revert the input field to the old name
                 console.log("Rename cancelled or empty name provided.");
                 conversationTitleInput.value = conversations[id]?.name || "Chat";
            }
        }

        /**
         * Deletes a conversation after confirmation.
         * @param {string} id The ID of the conversation to delete.
         */
        function deleteConversation(id) {
            if (!conversations[id]) return;

            // Prevent deleting the last conversation
            if (Object.keys(conversations).length <= 1) {
                alert("Cannot delete the last conversation.");
                return;
            }

            // Confirmation is handled by the context menu event handler now
            console.log("Deleting conversation:", id);
            const deletedName = conversations[id].name; // Get name before deleting
            delete conversations[id]; // Remove from the object

            // If the deleted conversation was the active one, load another one
            if (currentConversationId === id) {
                currentConversationId = null; // Reset current ID
                // Find the most recent remaining conversation
                const remainingIds = Object.keys(conversations).sort((a, b) =>
                     new Date(conversations[b]?.createdAt || 0) - new Date(conversations[a]?.createdAt || 0)
                );
                if (remainingIds.length > 0) {
                    console.log(`Deleted active conversation "${deletedName}", loading ${remainingIds[0]}`);
                    loadConversation(remainingIds[0]); // Load the newest remaining
                } else {
                    // Should not happen due to the "last conversation" check, but fallback just in case
                    console.log(`Deleted active conversation "${deletedName}", creating new one.`);
                    createNewConversation();
                }
            } else {
                // If a non-active conversation was deleted, just save and re-render
                saveConversations();
                renderConversationList();
                console.log(`Deleted conversation "${deletedName}".`);
            }
            // Note: loadConversation or createNewConversation will call saveConversations and renderConversationList
        }

        /**
         * Deletes a specific message from the current conversation history and DOM.
         * @param {string} messageId The ID of the message to delete.
         */
        function deleteMessageHandler(messageId) {
            if (!currentConversationId || !conversations[currentConversationId]) return;

            const conversation = conversations[currentConversationId];
            const messageIndex = conversation.history.findIndex(msg => msg.id === messageId);

            if (messageIndex > -1) {
                // Remove the message from the history array
                conversation.history.splice(messageIndex, 1);
                saveConversations(); // Save the change
                console.log("Deleted message from history:", messageId);
            } else {
                console.warn("Message ID not found in history:", messageId);
            }

            // Always try to remove the message element from the DOM
            const messageElement = chatContainer.querySelector(`.message[data-message-id="${messageId}"]`);
            if (messageElement) {
                messageElement.remove();
                console.log("Removed message element from DOM:", messageId);
            } else {
                 console.warn("Message element not found in DOM for ID:", messageId);
            }
        }

        /**
         * Shows the modal for viewing/editing conversation history.
         */
        function showHistoryEditModal() {
            if (!currentConversationId || !conversations[currentConversationId]) return;

            const conversation = conversations[currentConversationId];
            historyEditContent.innerHTML = ''; // Clear previous content

            if (!conversation.history || conversation.history.length === 0) {
                historyEditContent.innerHTML = '<p class="placeholder-text">History is empty.</p>';
            } else {
                conversation.history.forEach(msg => {
                    if (!msg || typeof msg.role !== 'string' || typeof msg.content !== 'string') {
                        console.warn("Skipping invalid message during history edit display:", msg);
                        return; // Skip invalid messages
                    }

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'history-item'; // Use class for styling
                    itemDiv.dataset.messageId = msg.id || generateId(); // Ensure there's an ID

                    const roleLabel = document.createElement('strong');
                    roleLabel.className = 'history-item-role';
                    roleLabel.textContent = msg.role.charAt(0).toUpperCase() + msg.role.slice(1);
                    roleLabel.style.color = msg.role === 'user' ? 'var(--accent-primary)' : 'var(--text-secondary)';

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'history-item-content';
                    // Display content as pre-formatted text to preserve whitespace/newlines
                    contentDiv.textContent = msg.content;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.className = 'history-delete-btn';
                    deleteBtn.innerHTML = '&times; Delete'; // Use innerHTML for the times symbol
                    deleteBtn.onclick = () => {
                        // Confirm before deleting from the modal view
                        if (confirm(`Delete this ${msg.role} message?\n\n"${msg.content.substring(0, 50)}..."`)) {
                            deleteMessageHandler(itemDiv.dataset.messageId); // Use the actual delete handler
                            itemDiv.remove(); // Remove from modal view
                            // Check if the modal content is now empty
                            if (!historyEditContent.querySelector('.history-item')) {
                                historyEditContent.innerHTML = '<p class="placeholder-text">History is empty.</p>';
                            }
                        }
                    };

                    itemDiv.appendChild(roleLabel);
                    itemDiv.appendChild(contentDiv);
                    itemDiv.appendChild(deleteBtn);
                    historyEditContent.appendChild(itemDiv);
                });
            }
            historyEditModal.classList.add('active'); // Show the modal
        }

        /**
         * Renders an artifact in the right panel.
         * @param {object} artifact The artifact object { id, type, title, content, language? }.
         */
        function renderArtifact(artifact) {
            if (!artifact || !artifact.content) {
                console.warn("Attempted to render invalid artifact:", artifact);
                return;
            }

            const artifactId = artifact.id || generateId(); // Ensure artifact has an ID

            // Check if artifact already exists in the panel to prevent duplicates
            if (rightPanel.querySelector(`.artifact[data-artifact-id="${artifactId}"]`)) {
                console.log("Artifact already rendered:", artifactId);
                return;
            }

            // Ensure right panel is visible
            if (!rightPanel.classList.contains('visible')) {
                rightPanel.classList.add('visible');
            }

            // Remove the initial placeholder text if it exists
            const placeholder = rightPanel.querySelector('h3[style*="text-align: center"]');
            if (placeholder && placeholder.textContent.includes('Details & Artifacts')) {
                placeholder.remove();
            }

            const artifactDiv = document.createElement('div');
            artifactDiv.className = 'artifact';
            artifactDiv.dataset.artifactId = artifactId;

            const type = artifact.type || 'text';
            // Sanitize title and type for display
            const title = sanitizeHTML(artifact.title || `Artifact (${type})`);
            const safeType = sanitizeHTML(type);

            let contentHtml = '';
            // Sanitize content differently based on type
            if (type === 'code' || type === 'csv' || type === 'json') {
                const lang = sanitizeHTML(artifact.language || (type === 'csv' ? 'csv' : (type === 'json' ? 'json' : '')));
                // Use textContent within code tag for automatic HTML escaping
                const codeElement = document.createElement('code');
                if (lang) codeElement.className = `language-${lang}`;
                codeElement.textContent = artifact.content;
                contentHtml = `<pre>${codeElement.outerHTML}</pre>`;
            } else if (type === 'markdown') {
                 contentHtml = parseAndSanitizeMarkdown(artifact.content); // Use combined function
            } else { // Default to plain text, preserve line breaks, sanitize
                contentHtml = `<p>${sanitizeHTML(artifact.content).replace(/\n/g, '<br>')}</p>`;
            }

            artifactDiv.innerHTML = `
                <div class="artifact-header">
                    <span class="artifact-title">${title}</span>
                    <span class="artifact-type">${safeType}</span>
                </div>
                <div class="artifact-content">${contentHtml}</div>
            `;

            rightPanel.appendChild(artifactDiv);

            // Apply syntax highlighting AFTER appending to DOM
            highlightCodeInElement(artifactDiv);

            // Add artifact to conversation state if not already there
            const currentConv = conversations[currentConversationId];
            if (currentConv) {
                if (!currentConv.artifacts) {
                    currentConv.artifacts = [];
                }
                // Add only if it doesn't exist by ID
                if (!currentConv.artifacts.some(a => a.id === artifactId)) {
                     // Store a copy of the artifact data with the ensured ID
                     currentConv.artifacts.push({ ...artifact, id: artifactId });
                     saveConversations(); // Save the updated conversation state
                     console.log("Added artifact to conversation state:", artifactId);
                }
            }
        }

        /**
         * Toggles between chat view and dashboard view.
         */
        function toggleViewMode() {
            const docViewer = document.getElementById('documentViewerPlaceholder');
            const currentConv = conversations[currentConversationId];

            if (currentViewMode === 'chat') {
                currentViewMode = 'dashboard';
                // mainContent.classList.add('dashboard-view'); // Use specific element display toggles
                inputContainer.style.display = 'none';
                chatContainer.style.display = 'none'; // Hide chat container too
                analysisDashboard.style.display = 'flex';
                viewModeToggle.textContent = 'Chat View';
                viewModeToggle.title = 'Switch to Chat View';

                // Update document viewer based on current conversation
                if (docViewer) {
                     if (currentConv?.associatedDocument) {
                         // TODO: Implement actual document loading/rendering here
                         docViewer.innerHTML = `<span>Preview for ${sanitizeHTML(currentConv.associatedDocument.name)}</span>`;
                     } else {
                         docViewer.innerHTML = `<span>No document loaded.</span>`;
                     }
                }
                // Ensure right panel (for artifacts/details) is visible in dashboard mode
                rightPanel.classList.add('visible');

            } else { // Switching back to chat view
                currentViewMode = 'chat';
                // mainContent.classList.remove('dashboard-view');
                inputContainer.style.display = 'block';
                chatContainer.style.display = 'flex'; // Show chat container again
                analysisDashboard.style.display = 'none';
                viewModeToggle.textContent = 'Dashboard View';
                viewModeToggle.title = 'Switch to Dashboard View';

                // Hide right panel only if it contains no artifacts
                if (!rightPanel.querySelector('.artifact')) {
                    rightPanel.classList.remove('visible');
                }
                chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'instant' }); // Scroll to bottom
            }
        }

        /**
         * Toggles the visibility of the batch processing panel.
         */
        function toggleBatchPanel() {
            isBatchPanelVisible = !isBatchPanelVisible;
            batchProcessingPanel.classList.toggle('visible', isBatchPanelVisible);
            if (isBatchPanelVisible) {
                fetchBatchJobs(); // Fetch jobs when panel becomes visible
            }
        }

        /**
         * Fetches and displays batch job status (mock implementation).
         */
        async function fetchBatchJobs() {
            console.log("Fetching batch jobs...");
            batchQueueList.innerHTML = '<div class="placeholder-text">Loading...</div>';

            try {
                // Simulate API call delay
                await new Promise(resolve => setTimeout(resolve, 800));

                // --- Mock Data ---
                const mockJobs = [
                    { id: 'batch001', name: 'Batch_Report_01 (100 docs)', status: 'processing', progress: 75 },
                    { id: 'batch002', name: 'Hist_Analysis (5 docs)', status: 'completed', progress: 100 },
                    { id: 'batch003', name: 'Urgent_Review (1 doc)', status: 'failed', progress: 0 },
                    { id: 'batch004', name: 'Pending_Uploads (20 docs)', status: 'pending', progress: 0 }
                ];
                // --- End Mock Data ---

                // Replace with actual fetch:
                // const response = await fetch(BATCH_API_ENDPOINT);
                // if (!response.ok) throw new Error(`Failed to fetch batch jobs: ${response.statusText}`);
                // const jobs = await response.json();
                const jobs = mockJobs; // Use mock data

                batchQueueList.innerHTML = ''; // Clear loading/placeholder

                if (!jobs || jobs.length === 0) {
                    batchQueueList.innerHTML = '<div class="placeholder-text">No active batch jobs.</div>';
                    return;
                }

                jobs.forEach(job => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'batch-item';
                    itemDiv.dataset.jobId = job.id;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'batch-item-name';
                    nameSpan.textContent = job.name;
                    nameSpan.title = job.name; // Add tooltip for long names

                    const statusContainer = document.createElement('div');
                    statusContainer.className = 'batch-item-status-container';

                    const statusSpan = document.createElement('span');
                    const statusText = job.status.charAt(0).toUpperCase() + job.status.slice(1);
                    statusSpan.className = `batch-item-status ${job.status}`;
                    statusSpan.textContent = statusText;

                    statusContainer.appendChild(statusSpan);

                    // Add progress bar only if processing or completed
                    if (job.status === 'processing' || job.status === 'completed') {
                        const progressDiv = document.createElement('div');
                        progressDiv.className = 'batch-item-progress';
                        const progressBar = document.createElement('div');
                        progressBar.className = 'batch-item-progress-bar';
                        progressBar.style.width = `${job.progress || 0}%`;
                        progressDiv.appendChild(progressBar);
                        statusContainer.appendChild(progressDiv);
                    }

                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(statusContainer);
                    batchQueueList.appendChild(itemDiv);
                });

            } catch (error) {
                console.error("Error fetching batch jobs:", error);
                batchQueueList.innerHTML = '<div class="placeholder-text" style="color: var(--danger-color);">Error loading batch jobs.</div>';
            }
        }

        /**
         * Switches the active tab in the settings panel.
         * @param {string} tabName The data-tab value of the tab to activate.
         */
        function switchSettingsTab(tabName) {
            settingsTabs.forEach(tab => tab.classList.remove('active'));
            settingsContents.forEach(content => content.classList.remove('active'));

            const activeTab = document.querySelector(`.settings-tab[data-tab="${tabName}"]`);
            if (activeTab) activeTab.classList.add('active');

            const activeContent = document.getElementById(`settings-tab-${tabName}`);
            if (activeContent) activeContent.classList.add('active');
        }

        /**
         * Updates the settings UI controls based on the current global state.
         */
        function updateSettingsUI() {
            // Update controls based on the global state variables
            // (which should have been loaded from the current conversation)
            modelSelector.value = selectedModel;
            activeModelDisplay.textContent = `Current: ${selectedModel}`;
            temperatureSlider.value = currentTemperature;
            temperatureValue.textContent = currentTemperature.toFixed(1);
            thinkingModeToggle.checked = isThinkingModeEnabled;
            webSearchToggle.checked = isWebSearchEnabled;

            // Update response style radio buttons safely
            const styleRadioButton = document.querySelector(`input[name="responseStyle"][value="${currentResponseStyle}"]`);
            if (styleRadioButton) {
                styleRadioButton.checked = true;
            } else {
                // Fallback if the saved style is invalid
                document.querySelector('input[name="responseStyle"][value="normal"]').checked = true;
            }

            dataResidency.value = currentDataResidency;
            medTermToggle.checked = isMedTermEnabled;
            equipSpecToggle.checked = isEquipSpecEnabled;
            ragToggle.checked = isRagEnabled;
            kbEndpoint.value = currentKbEndpoint;
        }

        // --- Notepad Functions ---

        /**
         * Saves the current notepad content to the active conversation object.
         */
        function saveNotepadContent() {
            const content = notepadContent.innerHTML; // Get HTML content

            // Save ONLY to the current conversation object
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].notepadContent = content;
                saveConversations(); // Save the entire conversations object
                // console.log("Notepad content saved to conversation:", currentConversationId);
            } else {
                console.warn("Cannot save notepad content: No active conversation.");
            }
        }

        /**
         * Loads notepad content from the active conversation object.
         */
        function loadNotepadContent() {
            let contentToLoad = '';
            // Load ONLY from the current conversation
            if (currentConversationId && conversations[currentConversationId]) {
                contentToLoad = conversations[currentConversationId].notepadContent || '';
                // console.log("Loading notepad from current conversation:", currentConversationId);
            } else {
                 console.log("No active conversation to load notepad content from.");
                 contentToLoad = ''; // Default to empty if no conversation
            }

            notepadContent.innerHTML = contentToLoad; // Set HTML content
            updateNotepadStatus('Ready');
        }

        /**
         * Updates the status message in the notepad footer.
         * @param {string} message The status message to display.
         */
        function updateNotepadStatus(message) {
            if (!notepadStatus) return; // Guard against element not found
            notepadStatus.textContent = message;
            notepadStatus.style.opacity = '1';
            // Clear any existing timeout to prevent premature fading
            if (window.notepadStatusTimeout) {
                clearTimeout(window.notepadStatusTimeout);
            }
            // Set a new timeout to fade the message
            window.notepadStatusTimeout = setTimeout(() => {
                if (notepadStatus) notepadStatus.style.opacity = '0.7';
            }, 2000); // Increased duration
        }

        /**
         * Initializes the notepad, loads content, and sets up the AI update function.
         */
        function initializeNotepad() {
            loadNotepadContent(); // Load initial content based on the active conversation
            notepadContent.setAttribute('data-placeholder', 'Type notes here... Use /note in chat or ask AI to edit.');
            updateNotepadStatus('Ready');

            // Define the function for AI updates globally or attach to window
            window.updateNotepadFromAI = function(newContentHtml, highlightChanges = true) {
                console.log("Updating notepad from AI.");
                // Sanitize the HTML received from the AI before inserting
                const sanitizedHtml = sanitizeHTML(newContentHtml); // *** CRITICAL: Sanitize AI output ***
                notepadContent.innerHTML = sanitizedHtml;

                if (highlightChanges) {
                    // Apply highlight to top-level block elements for visual feedback
                    const elements = notepadContent.querySelectorAll(':scope > p, :scope > li, :scope > h1, :scope > h2, :scope > h3, :scope > h4, :scope > h5, :scope > h6, :scope > div, :scope > pre, :scope > blockquote, :scope > table');
                    elements.forEach(el => {
                        if (el.textContent.trim().length > 0) { // Check if element has content
                            el.classList.add('ai-edit-highlight');
                            // Rely on CSS animation to fade out
                        }
                    });
                }

                saveNotepadContent(); // Save the updated content
                updateNotepadStatus('Updated by AI');

                // Ensure notepad is visible after AI update
                if (!notepadContainer.classList.contains('visible')) {
                    notepadContainer.classList.add('visible');
                }
            };
        }

        /**
         * Checks AI message for notepad edit command and updates notepad if found.
         * @param {string} aiMessage The full message content from the AI.
         * @returns {string} The AI message with the notepad command removed, or the original message.
         */
        function handleAINotepadEdit(aiMessage) {
            // Regex to find the notepad content block, case-insensitive and multiline
            const notepadRegex = /\[NOTEPAD:BEGIN\]([\s\S]*?)\[NOTEPAD:END\]/im;
            const match = aiMessage.match(notepadRegex);

            if (match && match[1]) {
                console.log("Found notepad edit command in AI response.");
                const notepadContentHtml = match[1].trim(); // Extract content

                // Check if the update function exists
                if (typeof window.updateNotepadFromAI === 'function') {
                    // Pass the raw HTML block (it will be sanitized by updateNotepadFromAI)
                    window.updateNotepadFromAI(notepadContentHtml);
                } else {
                    console.error("updateNotepadFromAI function is not defined.");
                }

                // Return the original message *without* the notepad block
                return aiMessage.replace(notepadRegex, '').trim();
            }
            // If no notepad block found, return the original message unchanged
            return aiMessage;
        }

        // --- Core API Interaction ---
        /**
         * Sends the user message and context to the backend LLM API.
         */
        async function sendMessageToLLM() {
            const messageText = messageInput.value.trim();
            const currentConv = conversations[currentConversationId];

            if (!currentConv) {
                alert("Error: No active conversation selected.");
                return;
            }
            // Proceed only if there's text OR a file staged
            if (!messageText && !selectedFile) {
                console.log("Send cancelled: No message text or staged file.");
                return;
            }

            isWaitingForResponse = true;
            updateButtonStates(); // Disable send button

            // Abort previous request if any
            if (currentAbortController) {
                currentAbortController.abort();
                console.log("Aborted previous API request.");
            }
            currentAbortController = new AbortController();

            const userMessageId = generateId();

            // Add user message to chat and history only if there is text
            if (messageText) {
                addMessage(messageText, 'user', { messageId: userMessageId });
                currentConv.history.push({ role: 'user', content: messageText, id: userMessageId });
            }

            // Handle staged file attachment
            let filePayload = null;
            const stagedFile = selectedFile; // Use the staged file
            if (stagedFile) {
                 // Placeholder message should already be added by confirmUpload handler
                 console.log("Including staged file in payload:", stagedFile.name);
                 filePayload = {
                     name: stagedFile.name,
                     type: stagedFile.type,
                     // Base64 is included when the file is read in handleFiles
                     base64: stagedFile.base64,
                     // Include processing options selected in the modal
                     processingOptions: { ...currentUploadOptions } // Send copy
                 };
                 // Associate document with conversation if not already done
                 if (!currentConv.associatedDocument) {
                     currentConv.associatedDocument = { name: stagedFile.name, type: stagedFile.type, id: generateId() };
                     // Update dashboard view if currently active
                     if (currentViewMode === 'dashboard') {
                         const docViewer = document.getElementById('documentViewerPlaceholder');
                         if (docViewer) {
                             docViewer.innerHTML = `<span>Loading ${sanitizeHTML(stagedFile.name)}...</span>`;
                         }
                     }
                 }
                 selectedFile = null; // IMPORTANT: Clear the staged file after preparing payload
            }

            messageInput.value = ''; // Clear input field
            autoResizeTextarea(); // Resize input field

            // Construct payload for the API
            const payload = {
                message: messageText, // Send the user's text message
                // Send a reasonable amount of recent history (e.g., last 10 turns = 20 messages)
                // Ensure history items are valid before sending
                history: currentConv.history?.filter(msg => msg && msg.role && typeof msg.content === 'string').slice(-20) || [],
                model: selectedModel,
                temperature: currentTemperature,
                responseStyle: currentResponseStyle,
                thinkingMode: isThinkingModeEnabled,
                webSearch: isWebSearchEnabled,
                enableMedicalTerms: isMedTermEnabled,
                enableEquipmentAnalysis: isEquipSpecEnabled,
                enableRag: isRagEnabled,
                knowledgeBaseEndpoint: isRagEnabled ? currentKbEndpoint : null,
                file: filePayload, // Include file payload if a file was staged
                conversationId: currentConversationId,
                dataResidency: currentDataResidency,
            };

            removeStreamingIndicator(); // Remove any previous indicators
            const assistantMessageId = generateId();
            // Add placeholder for assistant response
            currentStreamingMessageElement = addMessage("", 'assistant', { messageId: assistantMessageId });
            currentStreamingMessageElement.classList.add('streaming');

            let fullResponseText = "";
            let receivedCitations = null;
            let receivedArtifacts = []; // Store artifacts received during streaming
            let receivedConfidence = null;

            try {
                console.log("Sending payload (structure):", { ...payload, file: payload.file ? {...payload.file, base64: "[omitted]"} : null, history: `[${payload.history?.length || 0} items]` });

                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' }, // Expect SSE
                    body: JSON.stringify(payload),
                    signal: currentAbortController.signal
                });

                if (!response.ok) {
                    let errorBody = await response.text();
                    try { errorBody = JSON.parse(errorBody).error || errorBody; } catch { /* ignore */ }
                    throw new Error(`API Error (${response.status}): ${errorBody || response.statusText}`);
                }

                // --- Process Streaming Response (Server-Sent Events) ---
                const reader = response.body?.getReader();
                if (!reader) throw new Error("Failed to get response reader.");

                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        console.log("Stream finished.");
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });
                    // Process buffer line by line (SSE lines end with \n\n)
                    let boundary = buffer.indexOf('\n\n');
                    while (boundary >= 0) {
                        const chunk = buffer.substring(0, boundary);
                        buffer = buffer.substring(boundary + 2); // Move past \n\n

                        let dataLine = '';
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data:')) {
                                dataLine += line.substring(5).trim(); // Accumulate data lines if split
                            }
                            // Can also handle 'event:' or 'id:' lines here if needed
                        }

                        if (dataLine) {
                            try {
                                const jsonData = JSON.parse(dataLine);

                                if (jsonData.type === 'chunk' && typeof jsonData.content === 'string') {
                                    fullResponseText += jsonData.content;
                                    // Update message bubble content progressively (parse Markdown & sanitize)
                                    if (currentStreamingMessageElement) {
                                         currentStreamingMessageElement.innerHTML = parseAndSanitizeMarkdown(fullResponseText);
                                         chatContainer.scrollTop = chatContainer.scrollHeight;
                                    }
                                } else if (jsonData.type === 'citation') {
                                    receivedCitations = jsonData.data;
                                } else if (jsonData.type === 'artifact') {
                                    receivedArtifacts.push(jsonData.data);
                                    renderArtifact(jsonData.data); // Render artifact immediately
                                } else if (jsonData.type === 'confidence' && typeof jsonData.score === 'number') {
                                    receivedConfidence = jsonData.score;
                                } else if (jsonData.type === 'entity') {
                                    console.log("Received entity:", jsonData.data); // Handle as needed
                                } else if (jsonData.type === 'done') {
                                    console.log("Stream done signal received via data.");
                                } else {
                                     console.warn("Received unknown stream data type:", jsonData.type, jsonData);
                                }
                            } catch (e) {
                                console.error("Stream JSON parsing error:", e, "Data:", dataLine);
                            }
                        }
                        boundary = buffer.indexOf('\n\n'); // Look for next message boundary
                    } // End while boundary >= 0
                     // Ensure streaming indicator stays visible during processing
                     if (currentStreamingMessageElement && !currentStreamingMessageElement.classList.contains('streaming')) {
                         currentStreamingMessageElement.classList.add('streaming');
                     }
                } // End while true (reader loop)

                removeStreamingIndicator(); // Remove indicator after loop finishes

                // --- Handle Notepad Edit Command ---
                const cleanedResponseText = handleAINotepadEdit(fullResponseText);

                // --- Finalize Assistant Message Bubble ---
                if (currentStreamingMessageElement) {
                    // Update with the final, potentially cleaned text, parsed and sanitized
                    currentStreamingMessageElement.innerHTML = parseAndSanitizeMarkdown(cleanedResponseText);

                    // Re-append citations if received (replacing placeholders in the final HTML)
                    if (receivedCitations && receivedCitations.length > 0) {
                        const citationList = document.createElement('div');
                        citationList.className = 'citation-source-list';
                        let listHtml = '<h4>Sources:</h4><ul>';
                        receivedCitations.forEach((cite, index) => {
                            const citeNum = index + 1;
                            const regex = new RegExp(`\\[${citeNum}\\](?![\w-])`, 'g');
                            const safeTitle = sanitizeHTML(cite.title || cite.url);
                            const safeUrl = sanitizeHTML(cite.url);
                            currentStreamingMessageElement.innerHTML = currentStreamingMessageElement.innerHTML.replace(regex, `<span class="citation" title="${safeTitle}" data-url="${safeUrl}">[${citeNum}]</span>`);
                            listHtml += `<li>[${citeNum}] <a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeTitle}</a></li>`;
                        });
                        listHtml += '</ul>';
                        citationList.innerHTML = listHtml;
                        currentStreamingMessageElement.appendChild(citationList);
                    }

                    // Re-append confidence score if received
                    if (receivedConfidence !== null) {
                        const confidenceSpan = document.createElement('span');
                        confidenceSpan.className = 'confidence-score';
                        confidenceSpan.textContent = `(${(receivedConfidence * 100).toFixed(0)}%)`;
                        currentStreamingMessageElement.appendChild(document.createTextNode(' '));
                        currentStreamingMessageElement.appendChild(confidenceSpan);
                    }

                    // Final syntax highlighting run on the complete, cleaned content
                    highlightCodeInElement(currentStreamingMessageElement);

                } else {
                     // Fallback if element was somehow lost
                     console.warn("Streaming element missing, adding final message directly.");
                     addMessage(cleanedResponseText, 'assistant', {
                         messageId: assistantMessageId,
                         isHtml: false, // Let addMessage handle parsing/sanitizing
                         citations: receivedCitations,
                         confidence: receivedConfidence
                     });
                }

                // --- Add Final Assistant Response to History ---
                if (cleanedResponseText || receivedArtifacts.length > 0) {
                    currentConv.history.push({
                        role: 'assistant',
                        content: cleanedResponseText || "[Generated artifacts]",
                        id: assistantMessageId,
                        citations: receivedCitations,
                        // Store artifact IDs in history for reference
                        artifacts: receivedArtifacts.map(a => a.id || a.title || 'artifact'),
                        confidence: receivedConfidence
                    });
                }
                saveConversations(); // Save updated history and potentially artifacts

            } catch (error) {
                removeStreamingIndicator();
                console.error('Error during API call:', error);
                if (error.name === 'AbortError') {
                    console.log('Fetch aborted by user.');
                    // Optionally remove the placeholder if aborted quickly
                    if (currentStreamingMessageElement && fullResponseText.length < 10) {
                        currentStreamingMessageElement.remove();
                    } else if (currentStreamingMessageElement) {
                         currentStreamingMessageElement.classList.remove('streaming'); // Leave partial response
                         highlightCodeInElement(currentStreamingMessageElement); // Highlight what's there
                    }
                } else {
                    // Display error message in chat
                    addMessage(`Sorry, an error occurred: ${error.message}. Please try again.`, 'assistant', { messageId: generateId() });
                    // Remove the potentially incomplete streaming message element
                    if (currentStreamingMessageElement) {
                        currentStreamingMessageElement.remove();
                    }
                }
            } finally {
                // --- Cleanup ---
                isWaitingForResponse = false;
                updateButtonStates(); // Re-enable send button
                messageInput.focus();
                currentAbortController = null;
                removeStreamingIndicator(); // Final check
                // selectedFile = null; // Already cleared after preparing payload
            }
        }


        // --- Event Listeners ---

        // Send Button Click
        sendButton.addEventListener('click', sendMessageToLLM);

        // View Mode Toggle
        viewModeToggle.addEventListener('click', toggleViewMode);

        // Batch Processing Panel
        batchProcessingToggleBtn.addEventListener('click', toggleBatchPanel);
        closeBatchPanelBtn.addEventListener('click', toggleBatchPanel);
        startNewBatchBtn.addEventListener('click', () => {
            alert("Functionality to start a new batch job is not yet implemented.");
            // Future: Open a modal or form
        });

        // Settings Panel Tabs
        settingsTabs.forEach(tab => {
            tab.addEventListener('click', () => switchSettingsTab(tab.dataset.tab));
        });

        // Settings Controls - Update conversation state on change
        function createSettingChangeListener(key, valueExtractor) {
            return (e) => {
                const newValue = valueExtractor(e.target);
                window[key] = newValue; // Update global state variable (assuming names match)
                if (currentConversationId && conversations[currentConversationId]) {
                    conversations[currentConversationId][key] = newValue;
                    saveConversations();
                }
            };
        }
        dataResidency.addEventListener('change', createSettingChangeListener('currentDataResidency', target => target.value));
        medTermToggle.addEventListener('change', createSettingChangeListener('isMedTermEnabled', target => target.checked));
        equipSpecToggle.addEventListener('change', createSettingChangeListener('isEquipSpecEnabled', target => target.checked));
        ragToggle.addEventListener('change', createSettingChangeListener('isRagEnabled', target => target.checked));
        kbEndpoint.addEventListener('change', createSettingChangeListener('currentKbEndpoint', target => target.value)); // Use 'change' or 'blur'
        modelSelector.addEventListener('change', (e) => {
            selectedModel = e.target.value;
            activeModelDisplay.textContent = `Current: ${selectedModel}`;
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].model = selectedModel;
                saveConversations();
            }
        });
        temperatureSlider.addEventListener('input', (e) => { // Update display continuously
            currentTemperature = parseFloat(e.target.value);
            temperatureValue.textContent = currentTemperature.toFixed(1);
        });
        temperatureSlider.addEventListener('change', () => { // Save only when user releases slider
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].temperature = currentTemperature;
                saveConversations();
            }
        });
        thinkingModeToggle.addEventListener('change', createSettingChangeListener('isThinkingModeEnabled', target => target.checked));
        webSearchToggle.addEventListener('change', createSettingChangeListener('isWebSearchEnabled', target => target.checked));
        responseStyleOptions.forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.checked) {
                    currentResponseStyle = this.value;
                    if (currentConversationId && conversations[currentConversationId]) {
                        conversations[currentConversationId].responseStyle = currentResponseStyle;
                        saveConversations();
                    }
                }
            });
        });

        // File Upload Options (update internal state for next upload)
        enableOcr.addEventListener('change', (e) => currentUploadOptions.ocr = e.target.checked);
        extractTables.addEventListener('change', (e) => currentUploadOptions.tables = e.target.checked);
        segmentDoc.addEventListener('change', (e) => currentUploadOptions.segment = e.target.checked);
        workflowSelect.addEventListener('change', (e) => currentUploadOptions.workflow = e.target.value);

        // Chat Input & Submission
        messageInput.addEventListener('keydown', (e) => {
            // Send on Enter (but not Shift+Enter)
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent newline
                if (!sendButton.disabled) {
                    sendMessageToLLM();
                }
            }
            // Show templates on '/' only if input is empty or just '/'
            if (e.key === '/' && (messageInput.value.trim() === '' || messageInput.value.trim() === '/')) {
                 setTimeout(() => { // Delay allows '/' to appear for filtering if needed
                     renderTemplatesPopup();
                     templatesPopup.classList.add('active');
                 }, 10);
            }
        });
        messageInput.addEventListener('input', autoResizeTextarea); // Resize on input

        // Sidebar Actions
        settingsBtn.addEventListener('click', () => settingsPanel.classList.add('active'));
        closeSettings.addEventListener('click', () => settingsPanel.classList.remove('active'));
        newChatBtn.addEventListener('click', () => {
            createNewConversation();
            // Optional: Collapse sidebar on mobile after creating new chat
            if (sidebar.classList.contains('expanded') && window.innerWidth < 768) {
                sidebar.classList.remove('expanded');
                collapseToggleBtn.innerHTML = '<span>&gt;</span>';
                collapseToggleBtn.title = "Expand Menu";
            }
            messageInput.focus(); // Focus input on new chat
        });
        collapseToggleBtn.addEventListener('click', () => {
            sidebar.classList.toggle('expanded');
            const isExpanded = sidebar.classList.contains('expanded');
            collapseToggleBtn.innerHTML = isExpanded ? '<span>&lt;</span>' : '<span>&gt;</span>';
            collapseToggleBtn.title = isExpanded ? "Collapse Menu" : "Expand Menu";
        });

        // File Upload Modal
        uploadFileBtn.addEventListener('click', () => {
            resetFileUpload(); // Ensure modal is reset before showing
            fileUploadModal.classList.add('active');
        });
        closeFileUploadModal.addEventListener('click', () => fileUploadModal.classList.remove('active'));
        cancelUpload.addEventListener('click', () => {
            fileUploadModal.classList.remove('active');
            resetFileUpload(); // Also reset if cancelled
        });
        dropArea.addEventListener('click', () => fileInput.click()); // Trigger hidden file input
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        // Drag and Drop listeners
        dropArea.addEventListener('dragover', (e) => { e.preventDefault(); dropArea.classList.add('dragover'); });
        dropArea.addEventListener('dragleave', () => dropArea.classList.remove('dragover'));
        dropArea.addEventListener('drop', (e) => { e.preventDefault(); dropArea.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });

        // Confirm Upload Button (Stages the file, adds placeholder, closes modal)
        confirmUpload.addEventListener('click', () => {
            const fileInfoString = confirmUpload.dataset.fileInfo;
            if (fileInfoString) {
                try {
                    selectedFile = JSON.parse(fileInfoString); // Stage the file
                    fileUploadModal.classList.remove('active');
                    addFilePlaceholderMessage(selectedFile); // Add placeholder to chat
                    updateButtonStates(); // Enable send button if message is empty but file is present
                    messageInput.focus(); // Focus input for accompanying message
                    console.log("File staged:", selectedFile.name);
                } catch (e) {
                    console.error("Error parsing file info from button data:", e);
                    alert("An error occurred staging the file.");
                    resetFileUpload();
                }
            } else {
                console.warn("Confirm upload clicked, but no file info found.");
            }
        });

        // Conversation Management
        clearCurrentHistoryBtn.addEventListener('click', () => {
            if (!currentConversationId || !conversations[currentConversationId]) return;
            if (confirm(`Are you sure you want to clear all history, artifacts, and the associated document for "${sanitizeHTML(conversations[currentConversationId].name)}"? This cannot be undone.`)) {
                conversations[currentConversationId].history = []; // Clear history
                conversations[currentConversationId].artifacts = []; // Clear artifacts
                conversations[currentConversationId].associatedDocument = null; // Clear document link
                conversations[currentConversationId].notepadContent = ''; // Clear notepad too
                loadConversation(currentConversationId); // Reload to clear UI and add initial message
                // saveConversations() is called within loadConversation
                settingsPanel.classList.remove('active'); // Close settings panel
            }
        });
        viewEditHistoryBtn.addEventListener('click', showHistoryEditModal);
        closeHistoryModal.addEventListener('click', () => historyEditModal.classList.remove('active'));
        cancelHistoryEdit.addEventListener('click', () => historyEditModal.classList.remove('active'));

        // Conversation Title Rename
        conversationTitle.addEventListener('click', () => {
            conversationTitle.style.display = 'none';
            conversationTitleInput.style.display = 'inline-block';
            conversationTitleInput.value = conversationTitle.textContent; // Ensure current value
            conversationTitleInput.focus();
            conversationTitleInput.select();
        });
        conversationTitleInput.addEventListener('blur', () => { // Save on blur
            const newName = conversationTitleInput.value; // No trim here, renameConversation handles it
            if (currentConversationId) {
                renameConversation(currentConversationId, newName); // Handles empty name check
            }
            // Always revert display back
            conversationTitle.style.display = 'inline-block';
            conversationTitleInput.style.display = 'none';
            // Ensure static title reflects the final name (even if rename failed)
            conversationTitle.textContent = conversations[currentConversationId]?.name || "Chat";
        });
        conversationTitleInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                conversationTitleInput.blur(); // Trigger blur to save
            } else if (e.key === 'Escape') {
                // Revert input value and trigger blur to hide input
                conversationTitleInput.value = conversations[currentConversationId]?.name || "Chat";
                conversationTitleInput.blur();
            }
        });

        // Prompt Templates
        templateBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent document click listener closing it immediately
            renderTemplatesPopup(); // Re-render in case templates change
            templatesPopup.classList.toggle('active');
        });

        // Global Click Listener (for closing popups/modals)
        document.addEventListener('click', (event) => {
            // Close Settings Panel
            if (settingsPanel.classList.contains('active') && !settingsPanel.contains(event.target) && !settingsBtn.contains(event.target)) {
                settingsPanel.classList.remove('active');
            }
            // Close Templates Popup
            if (templatesPopup.classList.contains('active') && !templatesPopup.contains(event.target) && !templateBtn.contains(event.target)) {
                templatesPopup.classList.remove('active');
            }
            // Close History Edit Modal
            if (historyEditModal.classList.contains('active') && !historyEditModal.querySelector('.modal-content')?.contains(event.target)) {
                historyEditModal.classList.remove('active');
            }
            // Close File Upload Modal
            if (fileUploadModal.classList.contains('active') && !fileUploadModal.querySelector('.modal-content')?.contains(event.target)) {
                fileUploadModal.classList.remove('active');
                resetFileUpload(); // Reset if closed by clicking outside
            }
            // Notepad does NOT close on outside click
        });

        // --- Notepad Event Listeners ---
        notepadToggleBtn.addEventListener('click', () => {
            notepadContainer.classList.toggle('visible');
            if (notepadContainer.classList.contains('visible')) {
                notepadContent.focus();
            }
        });
        notepadCollapseBtn.addEventListener('click', () => {
            notepadContainer.classList.remove('visible');
        });
        notepadClearBtn.addEventListener('click', () => {
            if (notepadContent.textContent.trim() === '') return; // Only confirm if not empty
            if (confirm('Are you sure you want to clear all notes in the notepad?')) {
                notepadContent.innerHTML = '';
                saveNotepadContent(); // Save the empty state
                updateNotepadStatus('Cleared');
            }
        });
        notepadSaveBtn.addEventListener('click', () => {
            saveNotepadContent();
            updateNotepadStatus('Saved');
        });
        notepadAskLLMBtn.addEventListener('click', () => {
            const noteText = notepadContent.textContent.trim(); // Get plain text
            if (!noteText) {
                updateNotepadStatus('Notepad is empty');
                return;
            }
            // Construct the prompt for the LLM
            const prompt = `Please review, edit for clarity and organization, and potentially summarize the following notes. Format the output using basic HTML (paragraphs <p>, lists <ul><li>, bold <strong>). Respond ONLY with the edited notes enclosed in [NOTEPAD:BEGIN] and [NOTEPAD:END] tags.\n\nNotes:\n${noteText}`;

            messageInput.value = prompt; // Place prompt in main chat input
            updateNotepadStatus('Prompt ready in chat');
            autoResizeTextarea();
            updateButtonStates();
            messageInput.focus();
            // Optional: Close notepad after generating prompt
            // notepadContainer.classList.remove('visible');
        });

        // Auto-save notepad content after a delay on input (Debounce)
        notepadContent.addEventListener('input', () => {
            updateNotepadStatus('Editing...');
            clearTimeout(notepadSaveTimeout); // Reset timer
            notepadSaveTimeout = setTimeout(() => {
                saveNotepadContent();
                updateNotepadStatus('Auto-saved');
            }, 1500); // Auto-save after 1.5 seconds of inactivity
        });

        // Handle '/note' command in main input
        messageInput.addEventListener('keyup', function(e) {
            const value = this.value.trim();
            if (value.startsWith('/note ')) {
                const noteToAdd = value.substring(6); // Get text after '/note '

                if (noteToAdd) { // Only add if there's actual text
                    if (!notepadContainer.classList.contains('visible')) {
                        notepadContainer.classList.add('visible');
                    }

                    // Append the note as a new paragraph (or div)
                    const p = document.createElement('p');
                    p.textContent = noteToAdd; // Use textContent to prevent HTML injection
                    notepadContent.appendChild(p);

                    // Add a line break before the new paragraph if notepad isn't empty
                    if (notepadContent.innerHTML.length > p.outerHTML.length) {
                         notepadContent.insertBefore(document.createElement('br'), p);
                    }

                    notepadContent.scrollTop = notepadContent.scrollHeight; // Scroll to bottom
                    saveNotepadContent();
                    updateNotepadStatus('Note added from chat');

                    // Clear the main input field
                    this.value = '';
                    autoResizeTextarea();
                    updateButtonStates();

                    e.preventDefault(); // Prevent any default action
                }
            }
        });


        // --- Initialization ---
        /**
         * Initializes the application on DOMContentLoaded.
         */
        function initializeApp() {
             console.log("Initializing Enterprise App Concept...");
             // 1. Configure libraries (before use)
             if (typeof hljs !== 'undefined') {
                 hljs.configure({ ignoreUnescapedHTML: true });
             } else {
                 console.warn("highlight.js (hljs) not loaded.");
             }
             if (typeof marked === 'undefined') {
                 console.warn("marked.js not loaded. Markdown rendering will be basic.");
             }
             if (typeof DOMPurify === 'undefined') {
                 console.warn("DOMPurify not loaded. HTML sanitization will be basic/less secure.");
             }

             // 2. Load conversations (this selects/creates one and loads its state)
             loadConversations(); // Calls loadConversation or createNewConversation internally

             // 3. Initialize Notepad (loads content based on the now-active conversation)
             initializeNotepad();

             // 4. Final UI updates based on loaded state
             updateSettingsUI(); // Reflects settings of the loaded conversation
             autoResizeTextarea(); // Initial size adjustment
             updateButtonStates(); // Set initial button states

             // 5. Set initial view mode (ensure chat view is default)
             if (currentViewMode !== 'chat') {
                 toggleViewMode(); // Switch back to chat if somehow started in dashboard
             } else {
                 // Ensure elements are correctly displayed for chat view
                 inputContainer.style.display = 'block';
                 chatContainer.style.display = 'flex';
                 analysisDashboard.style.display = 'none';
                 viewModeToggle.textContent = 'Dashboard View';
                 viewModeToggle.title = 'Switch to Dashboard View';
             }

             // 6. Set initial focus
             messageInput.focus();

             // 7. Example: Update notification count (replace with actual logic)
             updateNotificationCount(3); // Example static count

             console.log("App Initialized. Current Conv ID:", currentConversationId);
        }

        /**
         * Updates the notification badge count.
         * @param {number} count The number of notifications.
         */
        function updateNotificationCount(count) {
            const numCount = parseInt(count, 10);
            if (!isNaN(numCount) && numCount > 0) {
                notificationBadge.textContent = numCount;
                notificationBadge.style.display = 'flex'; // Use flex for centering
            } else {
                notificationBadge.textContent = '0';
                notificationBadge.style.display = 'none';
            }
        }

        /**
         * Renders the prompt templates popup.
         */
        function renderTemplatesPopup() {
            templatesPopup.innerHTML = ''; // Clear previous items
            const promptTemplates = [
                { name: "Summarize Text", prompt: "Please summarize the following text:\n\n" },
                { name: "Explain Code", prompt: "Explain this code snippet:\n\n```\n[Your Code Here]\n```\n" },
                { name: "Translate to French", prompt: "Translate the following text to French:\n\n" },
                { name: "Brainstorm Ideas", prompt: "Brainstorm ideas for:\n\n" },
                { name: "Write Email", prompt: "Write a professional email about:\n\nSubject: [Subject]\n\nBody:\n" },
                { name: "Add to Notepad", prompt: "/note " } // Include /note command
            ];

            promptTemplates.forEach(template => {
                const item = document.createElement('div');
                item.className = 'template-item';

                // Sanitize name and preview before inserting
                const promptPreview = template.prompt.replace(/\n/g, ' ').substring(0, 50);
                item.innerHTML = `<strong>${sanitizeHTML(template.name)}</strong> ${sanitizeHTML(promptPreview)}...`;

                item.onclick = () => {
                    messageInput.value = template.prompt;
                    templatesPopup.classList.remove('active');
                    messageInput.focus();
                    // Move cursor to end for templates that expect input after them
                    const cursorPos = messageInput.value.length;
                    messageInput.setSelectionRange(cursorPos, cursorPos);
                    autoResizeTextarea();
                    updateButtonStates();
                };
                templatesPopup.appendChild(item);
            });
        }


        // Start the application once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>
    <title>GCT Enterprise App Concept</title>
    <!-- Remove or add actual CSS file -->
    <style>
        /* Add basic styles here if no external CSS */
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
             <button class="sidebar-button" id="newChatBtn" title="New Chat"><span>+</span> <span class="sidebar-item-text">New Chat</span></button>
             <button class="sidebar-button" id="collapseToggleBtn" title="Collapse Menu"><span>&lt;</span></button>
        </div>
        <div id="conversationList"></div>
        <div class="sidebar-section">
            <div class="sidebar-section-title">Workflows</div>
            <button class="sidebar-button" id="approvalQueueBtn" title="Approval Queue"><span>&#128204;</span> <span class="sidebar-item-text">Approvals <span class="badge">3</span></span></button>
             <button class="sidebar-button" id="batchProcessingToggleBtn" title="Batch Processing"><span>&#128230;</span> <span class="sidebar-item-text">Batch Jobs</span></button>
        </div>
         <div class="sidebar-section">
             <div class="sidebar-section-title">Knowledge</div>
             <button class="sidebar-button" id="docLibraryBtn" title="Document Library"><span>&#128193;</span> <span class="sidebar-item-text">Doc Library</span></button>
         </div>
        <div style="margin-top: auto; padding-top: 1rem; border-top: 1px solid var(--border-color); width: 100%;">
             <button class="sidebar-button" id="settingsBtn" title="Settings"><span>&#9881;</span> <span class="sidebar-item-text">Settings</span></button>
        </div>
    </div>

    <!-- Main Content Wrapper -->
    <div class="main-content-wrapper">
        <div class="main-content" id="mainContent">
            <!-- Header -->
            <header class="header">
                <div class="header-left">
                    <div class="app-info">
                        <h1 class="app-title">GCT Enterprise App Concept</h1>
                        <p class="app-subtitle">Enterprise Analysis Platform</p>
                    </div>
                    <h2 id="conversationTitle" title="Click to rename">Analysis Session</h2>
                    <input type="text" id="conversationTitleInput" placeholder="Enter new title..." />
                </div>
                <div class="header-right">
                    <button id="viewModeToggle" title="Toggle Dashboard View">Dashboard View</button>
                    <button id="notificationsBtn" title="Notifications">
                        <span>&#128276;</span>
                        <span id="notification-badge">0</span>
                    </button>
                    <div id="userProfilePlaceholder"></div>
                </div>
            </header>

            <!-- Chat Container -->
            <main class="chat-container" id="chatContainer"></main>

            <!-- Input Container -->
            <div class="input-container" id="inputContainer">
                <div class="input-wrapper">
                    <div class="templates-popup" id="templatesPopup"></div>
                    <form class="input-form" id="chatForm">
                        <div class="input-actions">
                            <button type="button" class="input-action-button" id="templateBtn" title="Prompt Templates"><span>&#128220;</span></button>
                            <button type="button" class="input-action-button" id="uploadFileBtn" title="Upload File"><span>&#128206;</span></button>
                            <!-- Notepad Toggle Button -->
                            <button type="button" class="input-action-button" id="notepadToggleBtn" title="Toggle Notepad"><span>&#128221;</span></button>
                            <input type="file" id="fileInput" accept="image/*,application/pdf,.txt,.csv,.json,.md,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/dicom,.dcm">
                        </div>
                        <textarea class="message-input" id="messageInput" placeholder="Ask about the document or use /note ..." rows="1"></textarea>
                        <button type="submit" class="send-button" id="sendButton" disabled>Send</button>
                    </form>
                </div>
            </div>

            <!-- Multimodal Analysis Dashboard -->
            <div class="analysis-dashboard" id="analysisDashboard">
                <!-- Dashboard content -->
                <div class="dashboard-section">
                    <h3 class="dashboard-section-title">Document Viewer</h3>
                    <div id="documentViewerPlaceholder">
                        <div id="annotationToolbar">
                            <button class="tool-btn" title="Select"> S </button>
                            <button class="tool-btn" title="Draw">‚úèÔ∏è</button>
                            <button class="tool-btn" title="Highlight"> H </button>
                            <button class="tool-btn" title="Text"> T </button>
                            <button class="tool-btn" title="Comment">üí¨</button>
                        </div>
                        <span>Document Preview Area</span>
                    </div>
                </div>
                 <div class="dashboard-section">
                     <h3 class="dashboard-section-title">Detected Entities & Analysis</h3>
                     <div id="entityHighlightPlaceholder">
                         <p>Measurements: <span style="background-color: rgba(255, 165, 0, 0.3); padding: 2px 4px; border-radius: 3px;">15.2mm</span> <span class="confidence-score">(98%)</span></p>
                         <p class="placeholder-text">Detected items will be listed here...</p>
                     </div>
                 </div>
                 <div class="dashboard-section">
                     <h3 class="dashboard-section-title">Advanced Analytics</h3>
                     <div id="timeSeriesChartPlaceholder">Time-Series Visualization</div>
                     <div id="anomalyVizPlaceholder">Anomaly Detection Visualization</div>
                     <div id="predictiveVizPlaceholder">Predictive Modeling Visualization</div>
                     <button class="settings-button" style="margin-top: 1rem; width: auto;">Compare with History</button>
                 </div>
            </div>
        </div>

        <!-- Right Panel (Artifacts / Details) -->
        <div class="right-panel" id="rightPanel">
            <h3 style="color: var(--text-muted); text-align: center; margin-bottom: 1rem;">Details & Artifacts</h3>
            <div class="artifact">
                <div class="artifact-header"><span class="artifact-title">Extracted Table</span><span class="artifact-type">CSV</span></div>
                <div class="artifact-content"><pre><code>ID,Value,Unit\n1,15.2,mm\n2,10.0,cm</code></pre></div>
            </div>
             <div class="settings-section" style="margin-top: 2rem;">
                 <h3 class="settings-section-title">Collaboration</h3>
                 <div class="placeholder-text">Comments and annotations appear here.</div>
                 <button class="settings-button primary">Share Findings</button>
                 <button class="settings-button">Export Report (PDF)</button>
             </div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
         <div class="settings-header">
             <h2 class="settings-title">Settings & Configuration</h2>
             <button class="close-settings" id="closeSettings">&times;</button>
         </div>
         <div class="settings-tabs">
             <button class="settings-tab active" data-tab="general">General</button>
             <button class="settings-tab" data-tab="model">Model</button>
             <button class="settings-tab" data-tab="security">Security</button>
             <button class="settings-tab" data-tab="workflows">Workflows</button>
             <button class="settings-tab" data-tab="integrations">Integrations</button>
             <button class="settings-tab" data-tab="knowledge">Knowledge</button>
         </div>
         <div class="settings-content-wrapper">
             <!-- General Settings Tab -->
             <div class="settings-content active" id="settings-tab-general">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Conversation</h3>
                     <button id="viewEditHistoryBtn" class="settings-button">View / Edit History</button>
                     <button id="clearCurrentHistoryBtn" class="settings-button danger">Clear Current Session History</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Response Style</h3>
                     <div class="settings-option"><input type="radio" id="professionalStyle" name="responseStyle" value="professional"><label for="professionalStyle">Professional</label></div>
                     <div class="settings-option"><input type="radio" id="conciseStyle" name="responseStyle" value="concise"><label for="conciseStyle">Concise</label></div>
                     <div class="settings-option"><input type="radio" id="normalStyle" name="responseStyle" value="normal" checked><label for="normalStyle">Normal</label></div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Advanced Modes</h3>
                     <div class="settings-option"><input type="checkbox" id="thinkingModeToggle"><label for="thinkingModeToggle">Enable Extended Reasoning</label></div>
                     <div class="settings-option"><input type="checkbox" id="webSearchToggle"><label for="webSearchToggle">Enable Web Search</label></div>
                 </div>
             </div>
             <!-- Model Settings Tab -->
             <div class="settings-content" id="settings-tab-model">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Model Selection</h3>
                     <div class="settings-option">
                         <select id="modelSelector">
                             <option value="llama3:8b">Llama 3 8B (Default)</option>
                             <option value="claude-3-sonnet">Claude 3 Sonnet</option>
                             <option value="gpt-4-turbo">GPT-4 Turbo</option>
                             <option value="domain-specific-med-v1">Domain: Medical v1</option>
                             <option value="domain-specific-eng-v2">Domain: Engineering v2</option>
                         </select>
                     </div>
                     <div id="activeModelDisplay" style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;">Current: llama3:8b</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Creativity (Temperature)</h3>
                     <div class="slider-container">
                         <input type="range" id="temperatureSlider" min="0" max="1.5" step="0.1" value="0.7">
                         <span id="temperatureValue">0.7</span>
                     </div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Model Management</h3>
                     <button class="settings-button">Manage Model Versions</button>
                     <button class="settings-button">Start Fine-tuning Job</button>
                     <button class="settings-button">View Performance Metrics</button>
                     <button class="settings-button">Configure A/B Test</button>
                     <div id="modelPerfDashboard" class="placeholder-text" style="margin-top: 1rem;">Model Performance Dashboard Area</div>
                 </div>
             </div>
             <!-- Security Settings Tab -->
             <div class="settings-content" id="settings-tab-security">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Compliance</h3>
                     <div class="compliance-logos">
                         <span class="tooltip"><img src="placeholder-soc2.png" alt="SOC 2"><span class="tooltiptext">SOC 2 Compliant</span></span>
                         <span class="tooltip"><img src="placeholder-hipaa.png" alt="HIPAA"><span class="tooltiptext">HIPAA Compliant</span></span>
                         <span class="tooltip"><img src="placeholder-gdpr.png" alt="GDPR"><span class="tooltiptext">GDPR Compliant</span></span>
                     </div>
                     <div class="settings-option" style="margin-top: 1rem;">
                         <label for="dataResidency" style="margin-left: 0; margin-right: 0.5rem; flex-shrink: 0;">Data Residency:</label>
                         <select id="dataResidency">
                             <option value="us">United States</option>
                             <option value="eu">European Union</option>
                             <option value="global">Global Default</option>
                         </select>
                     </div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Access Control</h3>
                     <button class="settings-button">Manage Users & Roles (RBAC)</button>
                     <button class="settings-button">Manage Document Permissions</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Auditing</h3>
                     <button class="settings-button">View Audit Logs</button>
                 </div>
             </div>
             <!-- Workflows Tab -->
             <div class="settings-content" id="settings-tab-workflows">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Workflow Management</h3>
                     <button class="settings-button">Create / Edit Workflows</button>
                     <div class="placeholder-text" style="margin-top: 1rem;">Workflow Editor Area</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Approval Settings</h3>
                     <button class="settings-button">Configure Approval Queues</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Domain Specific Enhancements</h3>
                      <div class="settings-option"><input type="checkbox" id="medTermToggle"><label for="medTermToggle">Enable Medical Terminology Validation</label></div>
                      <div class="settings-option"><input type="checkbox" id="equipSpecToggle"><label for="equipSpecToggle">Enable Equipment-Specific Analysis</label></div>
                 </div>
             </div>
              <!-- Integrations Tab -->
             <div class="settings-content" id="settings-tab-integrations">
                 <div class="settings-section">
                     <h3 class="settings-section-title">EHR / EMR Systems</h3>
                     <button class="settings-button primary">Connect to EHR/EMR</button>
                     <div class="placeholder-text">List of connected systems...</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Enterprise Systems</h3>
                     <button class="settings-button">Connect to SAP</button>
                     <button class="settings-button">Connect to Salesforce</button>
                     <div class="placeholder-text">List of connected systems...</div>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">API Access</h3>
                     <button class="settings-button">Manage API Keys</button>
                 </div>
             </div>
              <!-- Knowledge Base Tab -->
             <div class="settings-content" id="settings-tab-knowledge">
                 <div class="settings-section">
                     <h3 class="settings-section-title">Knowledge Base Connection</h3>
                     <div class="settings-option">
                         <label for="kbEndpoint" style="margin-left:0; margin-right: 0.5rem;">Endpoint:</label>
                         <input type="text" id="kbEndpoint" placeholder="Enter KB API endpoint...">
                     </div>
                      <div class="settings-option"><input type="checkbox" id="ragToggle"><label for="ragToggle">Enable Retrieval-Augmented Generation (RAG)</label></div>
                     <button class="settings-button primary" style="margin-top: 1rem;">Connect</button>
                 </div>
                 <div class="settings-section">
                     <h3 class="settings-section-title">Document Library Settings</h3>
                     <button class="settings-button">Configure Semantic Search</button>
                 </div>
             </div>
         </div>
    </div>

    <!-- File Upload Modal -->
    <div class="file-upload-modal" id="fileUploadModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Upload & Process File</h2>
                <button class="close-modal" id="closeFileUploadModal">&times;</button>
            </div>
            <div class="file-upload-area" id="dropArea">
                <p class="file-upload-text">Drag & drop file or click to browse (PDF, DOCX, XLSX, DICOM, Images, Text...)</p>
                <img src="" alt="Image Preview" class="file-preview" id="imagePreview">
                <div class="file-info" id="fileInfoPreview">
                    <span style="font-size: 2rem;">üìÑ</span>
                    <span id="fileNamePreview"></span> (<span id="fileSizePreview"></span>)
                </div>
            </div>
            <div class="upload-options">
                <h4>Processing Options</h4>
                <div class="settings-option"><input type="checkbox" id="enableOcr" checked><label for="enableOcr">Enable OCR</label></div>
                <div class="settings-option"><input type="checkbox" id="extractTables" checked><label for="extractTables">Extract Tables</label></div>
                <div class="settings-option"><input type="checkbox" id="segmentDoc"><label for="segmentDoc">Segment Document Sections</label></div>
                <div class="settings-option">
                     <label for="workflowSelect" style="margin-left:0; margin-right: 0.5rem;">Apply Workflow:</label>
                     <select id="workflowSelect">
                         <option value="default">Default Analysis</option>
                         <option value="medical_report">Medical Report Review</option>
                         <option value="engineering_spec">Engineering Spec Check</option>
                         <option value="financial_audit">Financial Audit Assist</option>
                     </select>
                 </div>
            </div>
            <div class="file-upload-buttons">
                <button class="cancel-button" id="cancelUpload">Cancel</button>
                <button class="upload-button" id="confirmUpload" disabled>Upload & Analyze</button>
            </div>
        </div>
    </div>

     <!-- History Edit Modal -->
     <div class="file-upload-modal" id="historyEditModal" style="align-items: flex-start; padding-top: 5vh;">
         <div class="modal-content" style="max-width: 700px; max-height: 80vh; display: flex; flex-direction: column;">
             <div class="modal-header">
                 <h2 class="modal-title">Edit Conversation History</h2>
                 <button class="close-modal" id="closeHistoryModal">&times;</button>
             </div>
             <div id="historyEditContent" style="flex-grow: 1; overflow-y: auto; border: 1px solid var(--border-color); padding: 1rem; border-radius: 8px; background: var(--bg-primary);"></div>
             <div style="margin-top: 1rem; text-align: right;">
                 <button class="cancel-button" id="cancelHistoryEdit">Close</button>
             </div>
         </div>
     </div>

     <!-- Batch Processing Panel -->
     <div class="batch-processing-panel" id="batchProcessingPanel">
         <div class="batch-panel-header">
             <h3 class="batch-panel-title">Batch Processing Queue</h3>
             <div class="batch-panel-actions">
                 <button class="settings-button primary" id="startNewBatchBtn">Start New Batch</button>
                 <button class="settings-button" id="closeBatchPanelBtn">&times;</button>
             </div>
         </div>
         <div class="batch-queue-list" id="batchQueueList">
             <div class="placeholder-text">No active batch jobs.</div>
         </div>
     </div>

    <!-- Notepad Container -->
    <div class="notepad-container" id="notepadContainer">
        <div class="notepad-header">
            <h3 class="notepad-title">Notepad</h3>
            <div class="notepad-actions">
                <button class="notepad-action" id="notepadClearBtn" title="Clear notepad"><span>&#128465;</span></button>
                <button class="notepad-action" id="notepadCollapseBtn" title="Hide notepad"><span>&#10006;</span></button>
            </div>
        </div>
        <div class="notepad-content" id="notepadContent" contenteditable="true" spellcheck="true"></div>
        <div class="notepad-footer">
            <div class="notepad-status" id="notepadStatus">Ready</div>
            <div class="notepad-buttons">
                <button class="notepad-footer-btn" id="notepadSaveBtn">Save</button>
                <button class="notepad-footer-btn" id="notepadAskLLMBtn">Ask AI to edit</button>
            </div>
        </div>
    </div>


    <script>
        // Initialize variables
        let currentViewMode = 'chat';
        let notificationBadge;

        function initializeNotepad() {
            notepadContent.innerHTML = localStorage.getItem('notepad') || '';
            updateNotepadStatus('Ready');
        }

        // --- DOM Elements ---
        const sidebar = document.getElementById('sidebar');
        const collapseToggleBtn = document.getElementById('collapseToggleBtn');
        const approvalQueueBtn = document.getElementById('approvalQueueBtn');
        const batchProcessingToggleBtn = document.getElementById('batchProcessingToggleBtn');
        const docLibraryBtn = document.getElementById('docLibraryBtn');
        const mainContent = document.getElementById('mainContent');
        const chatContainer = document.getElementById('chatContainer');
        const inputContainer = document.getElementById('inputContainer');
        const analysisDashboard = document.getElementById('analysisDashboard');
        const viewModeToggle = document.getElementById('viewModeToggle');
        const notificationsBtn = document.getElementById('notificationsBtn');
        const notificationBadge = document.getElementById('notification-badge');
        const rightPanel = document.getElementById('rightPanel');
        const settingsPanel = document.getElementById('settingsPanel');
        const settingsTabs = document.querySelectorAll('.settings-tab');
        const settingsContents = document.querySelectorAll('.settings-content');
        const closeSettings = document.getElementById('closeSettings');
        const fileUploadModal = document.getElementById('fileUploadModal');
        const enableOcr = document.getElementById('enableOcr');
        const extractTables = document.getElementById('extractTables');
        const segmentDoc = document.getElementById('segmentDoc');
        const workflowSelect = document.getElementById('workflowSelect');
        const batchProcessingPanel = document.getElementById('batchProcessingPanel');
        const batchQueueList = document.getElementById('batchQueueList');
        const startNewBatchBtn = document.getElementById('startNewBatchBtn');
        const closeBatchPanelBtn = document.getElementById('closeBatchPanelBtn');
        const chatForm = document.getElementById('chatForm');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const settingsBtn = document.getElementById('settingsBtn');
        const uploadFileBtn = document.getElementById('uploadFileBtn');
        const closeFileUploadModal = document.getElementById('closeFileUploadModal');
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('imagePreview');
        const fileInfoPreview = document.getElementById('fileInfoPreview');
        const fileNamePreview = document.getElementById('fileNamePreview');
        const fileSizePreview = document.getElementById('fileSizePreview');
        const confirmUpload = document.getElementById('confirmUpload');
        const cancelUpload = document.getElementById('cancelUpload');
        const clearCurrentHistoryBtn = document.getElementById('clearCurrentHistoryBtn');
        const viewEditHistoryBtn = document.getElementById('viewEditHistoryBtn');
        const historyEditModal = document.getElementById('historyEditModal');
        const closeHistoryModal = document.getElementById('closeHistoryModal');
        const cancelHistoryEdit = document.getElementById('cancelHistoryEdit');
        const historyEditContent = document.getElementById('historyEditContent');
        const newChatBtn = document.getElementById('newChatBtn');
        const responseStyleOptions = document.querySelectorAll('input[name="responseStyle"]');
        const conversationList = document.getElementById('conversationList');
        const conversationTitle = document.getElementById('conversationTitle');
        const conversationTitleInput = document.getElementById('conversationTitleInput');
        const modelSelector = document.getElementById('modelSelector');
        const activeModelDisplay = document.getElementById('activeModelDisplay');
        const temperatureSlider = document.getElementById('temperatureSlider');
        const temperatureValue = document.getElementById('temperatureValue');
        const thinkingModeToggle = document.getElementById('thinkingModeToggle');
        const webSearchToggle = document.getElementById('webSearchToggle');
        const templateBtn = document.getElementById('templateBtn');
        const templatesPopup = document.getElementById('templatesPopup');
        const dataResidency = document.getElementById('dataResidency');
        const medTermToggle = document.getElementById('medTermToggle');
        const equipSpecToggle = document.getElementById('equipSpecToggle');
        const ragToggle = document.getElementById('ragToggle');
        const kbEndpoint = document.getElementById('kbEndpoint');
        // Notepad DOM Elements
        const notepadContainer = document.getElementById('notepadContainer');
        const notepadContent = document.getElementById('notepadContent');
        const notepadToggleBtn = document.getElementById('notepadToggleBtn');
        const notepadCollapseBtn = document.getElementById('notepadCollapseBtn');
        const notepadClearBtn = document.getElementById('notepadClearBtn');
        const notepadStatus = document.getElementById('notepadStatus');
        const notepadSaveBtn = document.getElementById('notepadSaveBtn');
        const notepadAskLLMBtn = document.getElementById('notepadAskLLMBtn');


        // --- Global State ---
        let isBatchPanelVisible = false;
        let conversations = {};
        let currentConversationId = null;
        let selectedFile = null;
        let currentResponseStyle = 'normal';
        let currentTemperature = 0.7;
        let isThinkingModeEnabled = false;
        let isWebSearchEnabled = false;
        let selectedModel = 'llama3:8b';
        let isWaitingForResponse = false;
        let currentStreamingMessageElement = null;
        let currentAbortController = null;
        let currentDataResidency = 'us';
        let isMedTermEnabled = false;
        let isEquipSpecEnabled = false;
        let isRagEnabled = false;
        let currentKbEndpoint = '';
        let currentUploadOptions = { ocr: true, tables: true, segment: false, workflow: 'default' };


        // --- API Configuration ---
        const API_ENDPOINT = '/api/chat';
        const BATCH_API_ENDPOINT = '/api/batch';
        const WORKFLOW_API_ENDPOINT = '/api/workflows';

        // --- Helper Functions ---
        function generateId() { return Date.now().toString(36) + Math.random().toString(36).substring(2); }
        function formatBytes(bytes, decimals = 2) { if (bytes === 0) return '0 Bytes'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]; }
        function getFileIcon(mimeType) { if (mimeType.startsWith('image/')) return 'üñºÔ∏è'; if (mimeType.includes('pdf')) return 'üìÑ'; if (mimeType.includes('word')) return 'üìù'; if (mimeType.includes('sheet') || mimeType.includes('excel')) return 'üìä'; if (mimeType.startsWith('text/')) return 'üìú'; if (mimeType.includes('dicom')) return '‚öïÔ∏è'; return 'üìé'; }
        function addMessage(text, role, options = {}) {
            const { isHtml = false, messageId = generateId(), citations = null, confidence = null } = options;
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', `${role}-message`);
            messageDiv.dataset.messageId = messageId;

            let contentHtml = '';
            if (isHtml) { contentHtml = text; }
            else {
                const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
                contentHtml = text.replace(urlRegex, url => `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);
                contentHtml = contentHtml.replace(/\n/g, '<br>');
            }

            if (role === 'assistant') { contentHtml = marked.parse(contentHtml); }
            messageDiv.innerHTML = contentHtml;

            if (citations && citations.length > 0) {
                const citationList = document.createElement('div');
                citationList.className = 'citation-source-list';
                let listHtml = '<h4>Sources:</h4><ul>';
                citations.forEach((cite, index) => {
                    const citeNum = index + 1;
                    const placeholder = `[${citeNum}]`;
                    const regex = new RegExp(`\\\[${citeNum}\\\](?![\w-])`, 'g');
                    messageDiv.innerHTML = messageDiv.innerHTML.replace(regex, `<span class="citation" title="${cite.title || cite.url}" data-url="${cite.url}">[${citeNum}]</span>`);
                    listHtml += `<li>[${citeNum}] <a href="${cite.url}" target="_blank" rel="noopener noreferrer">${cite.title || cite.url}</a></li>`;
                });
                listHtml += '</ul>'; citationList.innerHTML = listHtml; messageDiv.appendChild(citationList);
            }

            if (role === 'assistant' && confidence !== null) {
                 const confidenceSpan = document.createElement('span');
                 confidenceSpan.className = 'confidence-score';
                 confidenceSpan.textContent = `(${(confidence * 100).toFixed(0)}%)`;
                 // Find first text node to append to, or just append at end
                 let inserted = false;
                 for(let node of messageDiv.childNodes) {
                     if(node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0) {
                         node.parentNode.insertBefore(confidenceSpan, node.nextSibling);
                         inserted = true;
                         break;
                     }
                 }
                 if (!inserted) messageDiv.appendChild(confidenceSpan);
            }

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-message-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.title = 'Delete message';
            deleteBtn.onclick = () => deleteMessageHandler(messageId); messageDiv.appendChild(deleteBtn);

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            actionsDiv.innerHTML = `<button class="message-action-btn" title="Add Comment">üí¨</button><button class="message-action-btn" title="Send to Approval">‚úîÔ∏è</button><button class="message-action-btn" title="Copy">üìã</button>`;
            messageDiv.appendChild(actionsDiv);

            chatContainer.appendChild(messageDiv);

            if (role === 'assistant') {
                messageDiv.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                    const pre = block.parentElement;
                    if (pre && pre.tagName === 'PRE') {
                        const copyBtn = document.createElement('button'); copyBtn.className = 'copy-code-btn'; copyBtn.textContent = 'Copy';
                        copyBtn.onclick = () => copyCodeHandler(block, copyBtn); pre.appendChild(copyBtn);
                    }
                });
            }
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
            return messageDiv;
        }
        function copyCodeHandler(block, button) { navigator.clipboard.writeText(block.textContent).then(() => { button.textContent = 'Copied!'; button.classList.add('copied'); setTimeout(() => { button.textContent = 'Copy'; button.classList.remove('copied'); }, 2000); }).catch(err => { console.error('Failed to copy code: ', err); button.textContent = 'Error'; setTimeout(() => { button.textContent = 'Copy'; }, 2000); }); }
        function addFilePlaceholderMessage(fileInfo) {
            const messageDiv = document.createElement('div'); messageDiv.classList.add('message', 'user-message'); messageDiv.dataset.messageId = generateId();
            let fileHtml = ''; const icon = getFileIcon(fileInfo.type);
            if (fileInfo.type.startsWith('image/')) { fileHtml = `<img src="${fileInfo.base64}" alt="${fileInfo.name}" style="max-width: 200px; max-height: 150px; border-radius: 0.5rem; margin-top: 0.5rem; display: block;">`; }
            else { fileHtml = `<div class="file-placeholder"><span>${icon}</span><span>${fileInfo.name} (${formatBytes(fileInfo.size)})</span></div>`; }
            messageDiv.innerHTML = `File ready: ${fileHtml}`;
            const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-message-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.title = 'Remove file attachment';
            deleteBtn.onclick = () => { selectedFile = null; messageDiv.remove(); updateButtonStates(); }; messageDiv.appendChild(deleteBtn);
            chatContainer.appendChild(messageDiv); chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
        }
        function removeStreamingIndicator() { if (currentStreamingMessageElement) { currentStreamingMessageElement.classList.remove('streaming'); currentStreamingMessageElement.querySelectorAll('pre code:not(.hljs)').forEach((block) => { hljs.highlightElement(block); const pre = block.parentElement; if (pre && pre.tagName === 'PRE' && !pre.querySelector('.copy-code-btn')) { const copyBtn = document.createElement('button'); copyBtn.className = 'copy-code-btn'; copyBtn.textContent = 'Copy'; copyBtn.onclick = () => copyCodeHandler(block, copyBtn); pre.appendChild(copyBtn); } }); currentStreamingMessageElement = null; } const typingIndicator = chatContainer.querySelector('.typing-indicator'); if (typingIndicator) typingIndicator.remove(); }
        function resetFileUpload() { fileInput.value = ''; imagePreview.src = ''; imagePreview.style.display = 'none'; fileInfoPreview.style.display = 'none'; fileNamePreview.textContent = ''; fileSizePreview.textContent = ''; selectedFile = null; confirmUpload.disabled = true; dropArea.classList.remove('dragover'); enableOcr.checked = true; extractTables.checked = true; segmentDoc.checked = false; workflowSelect.value = 'default'; }
        function handleFiles(files) { if (files.length > 0) { const file = files[0]; const reader = new FileReader(); reader.onload = function(e) { const base64Data = e.target.result; selectedFile = { name: file.name, type: file.type, size: file.size, base64: base64Data }; if (file.type.startsWith('image/')) { imagePreview.src = base64Data; imagePreview.style.display = 'block'; fileInfoPreview.style.display = 'none'; } else { imagePreview.style.display = 'none'; fileNamePreview.textContent = file.name; fileSizePreview.textContent = formatBytes(file.size); fileInfoPreview.style.display = 'block'; } confirmUpload.disabled = false; }; reader.onerror = function(e) { console.error("File reading error:", e); alert("Error reading file."); resetFileUpload(); }; reader.readAsDataURL(file); } }
        function updateButtonStates() { const messageText = messageInput.value.trim(); sendButton.disabled = (messageText.length === 0 && !selectedFile) || isWaitingForResponse; }
        function autoResizeTextarea() { messageInput.style.height = 'auto'; let scrollHeight = messageInput.scrollHeight; const maxHeight = parseInt(window.getComputedStyle(messageInput).maxHeight, 10); if (scrollHeight > maxHeight) { messageInput.style.height = maxHeight + 'px'; messageInput.style.overflowY = 'auto'; } else { messageInput.style.height = scrollHeight + 'px'; messageInput.style.overflowY = 'hidden'; } updateButtonStates(); }
        function loadConversations() { const storedConvs = localStorage.getItem('kynseyAiConversations'); if (storedConvs) { conversations = JSON.parse(storedConvs); } else { conversations = {}; } const lastConvId = localStorage.getItem('kynseyAiLastConversationId'); if (lastConvId && conversations[lastConvId]) { currentConversationId = lastConvId; } else if (Object.keys(conversations).length > 0) { currentConversationId = Object.keys(conversations)[0]; } else { createNewConversation(); } renderConversationList(); loadConversation(currentConversationId); }
        function saveConversations() { localStorage.setItem('kynseyAiConversations', JSON.stringify(conversations)); localStorage.setItem('kynseyAiLastConversationId', currentConversationId); }
        function createNewConversation(setActive = true) { const newId = generateId(); const timestamp = new Date(); const defaultName = `Analysis ${timestamp.toLocaleDateString()} ${timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`; conversations[newId] = { id: newId, name: defaultName, history: [], model: selectedModel, temperature: currentTemperature, thinkingMode: isThinkingModeEnabled, webSearch: isWebSearchEnabled, responseStyle: currentResponseStyle, dataResidency: currentDataResidency, medTermEnabled: isMedTermEnabled, equipSpecEnabled: isEquipSpecEnabled, ragEnabled: isRagEnabled, kbEndpoint: currentKbEndpoint, createdAt: timestamp.toISOString(), associatedDocument: null, notepadContent: '' /* Initialize notepad content */ }; if (setActive) { currentConversationId = newId; loadConversation(newId); renderConversationList(); saveConversations(); } return newId; }
        function loadConversation(id) { if (!conversations[id]) { console.error("Conversation not found:", id); if (Object.keys(conversations).length > 0) { loadConversation(Object.keys(conversations)[0]); } else { createNewConversation(); } return; } currentConversationId = id; const conv = conversations[id]; selectedModel = conv.model || 'llama3:8b'; currentTemperature = conv.temperature || 0.7; isThinkingModeEnabled = conv.thinkingMode || false; isWebSearchEnabled = conv.webSearch || false; currentResponseStyle = conv.responseStyle || 'normal'; currentDataResidency = conv.dataResidency || 'us'; isMedTermEnabled = conv.medTermEnabled || false; isEquipSpecEnabled = conv.equipSpecEnabled || false; isRagEnabled = conv.ragEnabled || false; currentKbEndpoint = conv.kbEndpoint || ''; updateSettingsUI(); conversationTitle.textContent = conv.name; conversationTitleInput.value = conv.name; chatContainer.innerHTML = ''; if (conv.history.length === 0) { const initialMsgId = generateId(); addMessage('Hello! How can I help you today?', 'assistant', { messageId: initialMsgId }); conv.history.push({ role: 'assistant', content: 'Hello! How can I help you today?', id: initialMsgId }); } else { conv.history.forEach(msg => { addMessage(msg.content, msg.role, { messageId: msg.id, isHtml: msg.role === 'assistant', citations: msg.citations, confidence: msg.confidence }); }); } if (currentViewMode === 'dashboard' && conv.associatedDocument) { document.getElementById('documentViewerPlaceholder').innerHTML = `Loading ${conv.associatedDocument.name}...`; } else if (currentViewMode === 'dashboard') { document.getElementById('documentViewerPlaceholder').innerHTML = `<span>No document loaded. Upload one.</span>`; } resetFileUpload(); messageInput.value = ''; autoResizeTextarea(); updateButtonStates(); highlightActiveConversation(); saveConversations(); rightPanel.innerHTML = '<h3 style="color: var(--text-muted); text-align: center; margin-bottom: 1rem;">Details & Artifacts</h3>'; rightPanel.classList.remove('visible'); conv.artifacts?.forEach(renderArtifact); /* Load artifacts if stored */ loadNotepadContent(); /* Load notepad */ }
        function renderConversationList() { conversationList.innerHTML = ''; const sortedIds = Object.keys(conversations).sort((a, b) => new Date(conversations[b].createdAt || 0) - new Date(conversations[a].createdAt || 0)); sortedIds.forEach(id => { const conv = conversations[id]; const item = document.createElement('button'); item.className = 'sidebar-item'; item.dataset.convId = id; item.title = conv.name; item.innerHTML = `<span>&#128172;</span><span class="sidebar-item-text">${conv.name}</span>`; item.onclick = () => loadConversation(id); conversationList.appendChild(item); }); highlightActiveConversation(); }
        function highlightActiveConversation() { document.querySelectorAll('.sidebar-item').forEach(item => { item.classList.toggle('active', item.dataset.convId === currentConversationId); }); }
        function renameConversation(id, newName) { if (conversations[id] && newName.trim()) { conversations[id].name = newName.trim(); saveConversations(); renderConversationList(); if (id === currentConversationId) { conversationTitle.textContent = newName.trim(); } } }
        function deleteConversation(id) { if (!conversations[id]) return; if (Object.keys(conversations).length <= 1) { alert("Cannot delete the last conversation."); return; } if (confirm(`Delete "${conversations[id].name}"?`)) { delete conversations[id]; if (currentConversationId === id) { currentConversationId = null; const remainingIds = Object.keys(conversations); if (remainingIds.length > 0) { loadConversation(remainingIds[0]); } else { createNewConversation(); } } saveConversations(); renderConversationList(); } }
        function deleteMessageHandler(messageId) { if (!currentConversationId || !conversations[currentConversationId]) return; const conversation = conversations[currentConversationId]; const messageIndex = conversation.history.findIndex(msg => msg.id === messageId); if (messageIndex > -1) { conversation.history.splice(messageIndex, 1); const messageElement = chatContainer.querySelector(`[data-message-id="${messageId}"]`); if (messageElement) { messageElement.remove(); } saveConversations(); console.log("Deleted message:", messageId); } else { console.warn("Message ID not found in history:", messageId); const messageElement = chatContainer.querySelector(`[data-message-id="${messageId}"]`); if (messageElement) messageElement.remove(); } }
        function showHistoryEditModal() { if (!currentConversationId || !conversations[currentConversationId]) return; const conversation = conversations[currentConversationId]; historyEditContent.innerHTML = ''; if (conversation.history.length === 0) { historyEditContent.innerHTML = '<p style="color: var(--text-muted);">History is empty.</p>'; } else { conversation.history.forEach(msg => { const itemDiv = document.createElement('div'); itemDiv.style.cssText = `margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px dashed var(--border-color);`; itemDiv.dataset.messageId = msg.id; const roleLabel = document.createElement('strong'); roleLabel.textContent = msg.role.charAt(0).toUpperCase() + msg.role.slice(1); roleLabel.style.color = msg.role === 'user' ? 'var(--accent-primary)' : 'var(--text-secondary)'; roleLabel.style.cssText = `display: block; margin-bottom: 0.3rem;`; const contentDiv = document.createElement('div'); contentDiv.textContent = msg.content; contentDiv.style.cssText = `white-space: pre-wrap; font-size: 0.9rem;`; const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = '&times; Delete'; deleteBtn.style.cssText = `float: right; background: none; border: 1px solid var(--danger-color); color: var(--danger-color); padding: 0.2rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 1rem;`; deleteBtn.onclick = () => { itemDiv.remove(); deleteMessageHandler(msg.id); if (historyEditContent.childElementCount === 0) { historyEditContent.innerHTML = '<p style="color: var(--text-muted);">History is empty.</p>'; } }; itemDiv.appendChild(deleteBtn); itemDiv.appendChild(roleLabel); itemDiv.appendChild(contentDiv); historyEditContent.appendChild(itemDiv); }); } historyEditModal.classList.add('active'); }
        function renderArtifact(artifact) { if (!rightPanel.classList.contains('visible')) { rightPanel.classList.add('visible'); } const placeholder = rightPanel.querySelector('h3'); if(placeholder && placeholder.textContent.includes('Artifacts')) placeholder.remove(); const artifactDiv = document.createElement('div'); artifactDiv.className = 'artifact'; artifactDiv.dataset.artifactId = artifact.id || generateId(); let contentHtml = ''; const type = artifact.type || 'text'; const title = artifact.title || `Artifact (${type})`; if (type === 'code') { const lang = artifact.language || ''; contentHtml = `<pre><code class="language-${lang}">${artifact.content}</code></pre>`; } else if (type === 'markdown') { contentHtml = marked.parse(artifact.content); } else { contentHtml = `<p>${artifact.content.replace(/\n/g, '<br>')}</p>`; } artifactDiv.innerHTML = `<div class="artifact-header"><span class="artifact-title">${title}</span><span class="artifact-type">${type}</span></div><div class="artifact-content">${contentHtml}</div>`; rightPanel.appendChild(artifactDiv); if (type === 'code') { artifactDiv.querySelectorAll('pre code').forEach(hljs.highlightElement); const pre = artifactDiv.querySelector('pre'); if (pre) { const block = pre.querySelector('code'); const copyBtn = document.createElement('button'); copyBtn.className = 'copy-code-btn'; copyBtn.textContent = 'Copy'; copyBtn.onclick = () => copyCodeHandler(block, copyBtn); pre.style.position = 'relative'; pre.appendChild(copyBtn); } } }
        function toggleViewMode() { if (currentViewMode === 'chat') { currentViewMode = 'dashboard'; mainContent.classList.add('dashboard-view'); inputContainer.style.display = 'none'; analysisDashboard.style.display = 'flex'; viewModeToggle.textContent = 'Chat View'; if (currentConversationId && conversations[currentConversationId]?.associatedDocument) { document.getElementById('documentViewerPlaceholder').innerHTML = `Loading ${conversations[currentConversationId].associatedDocument.name}...`; } else { document.getElementById('documentViewerPlaceholder').innerHTML = `<span>No document loaded.</span>`; } rightPanel.classList.add('visible'); } else { currentViewMode = 'chat'; mainContent.classList.remove('dashboard-view'); inputContainer.style.display = 'block'; analysisDashboard.style.display = 'none'; viewModeToggle.textContent = 'Dashboard View'; if (!rightPanel.querySelector('.artifact')) { rightPanel.classList.remove('visible'); } } }
        function toggleBatchPanel() { isBatchPanelVisible = !isBatchPanelVisible; batchProcessingPanel.classList.toggle('visible', isBatchPanelVisible); if (isBatchPanelVisible) { fetchBatchJobs(); } }
        async function fetchBatchJobs() { console.log("Fetching batch jobs..."); batchQueueList.innerHTML = '<div class="placeholder-text">Loading...</div>'; await new Promise(resolve => setTimeout(resolve, 1000)); batchQueueList.innerHTML = `<div class="batch-item"><span class="batch-item-name">Batch_Report_01 (100 docs)</span><div style="display: flex; align-items: center;"><span class="batch-item-status processing">Processing...</span><div class="batch-item-progress"><div class="batch-item-progress-bar" style="width: 75%;"></div></div></div></div><div class="batch-item"><span class="batch-item-name">Hist_Analysis (5 docs)</span><span class="batch-item-status completed">Completed</span></div><div class="batch-item"><span class="batch-item-name">Urgent_Review (1 doc)</span><span class="batch-item-status failed">Failed</span></div>`; }
        function switchSettingsTab(tabName) { settingsTabs.forEach(tab => tab.classList.toggle('active', tab.dataset.tab === tabName)); settingsContents.forEach(content => content.classList.toggle('active', content.id === `settings-tab-${tabName}`)); }
        function updateSettingsUI() { modelSelector.value = selectedModel; activeModelDisplay.textContent = `Current: ${selectedModel}`; temperatureSlider.value = currentTemperature; temperatureValue.textContent = currentTemperature.toFixed(1); thinkingModeToggle.checked = isThinkingModeEnabled; webSearchToggle.checked = isWebSearchEnabled; document.querySelector(`input[name="responseStyle"][value="${currentResponseStyle}"]`).checked = true; dataResidency.value = currentDataResidency; medTermToggle.checked = isMedTermEnabled; equipSpecToggle.checked = isEquipSpecEnabled; ragToggle.checked = isRagEnabled; kbEndpoint.value = currentKbEndpoint; }

        // --- Notepad Functions ---
        function saveNotepadContent() {
            const content = notepadContent.innerHTML; // Save HTML to preserve basic formatting
            localStorage.setItem('kynseyAiNotepadContent_global', content); // Use a distinct key for global

            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].notepadContent = content;
                saveConversations(); // This saves the whole conversations object
            }
             console.log("Notepad content saved.");
        }
        function loadNotepadContent() {
            let contentToLoad = '';
            // Try conversation-specific first
            if (currentConversationId && conversations[currentConversationId] && conversations[currentConversationId].notepadContent) {
                contentToLoad = conversations[currentConversationId].notepadContent;
                 console.log("Loading notepad from current conversation.");
            } else {
                // Fallback to global content
                contentToLoad = localStorage.getItem('kynseyAiNotepadContent_global') || '';
                 console.log("Loading notepad from global storage.");
            }
            notepadContent.innerHTML = contentToLoad;
            updateNotepadStatus('Ready');
        }
        function updateNotepadStatus(message) {
            notepadStatus.textContent = message;
            notepadStatus.style.opacity = '1';
            setTimeout(() => { notepadStatus.style.opacity = '0.7'; }, 1500);
        }
        function initializeNotepad() {
            loadNotepadContent(); // Load initial content
            notepadContent.setAttribute('data-placeholder', 'Type your notes here... Use /note in chat or ask AI to edit.');
            updateNotepadStatus('Ready');

            // Define the function for AI updates globally or attach to window
            window.updateNotepadFromAI = function(newContentHtml, highlightChanges = true) {
                console.log("Updating notepad from AI.");
                notepadContent.innerHTML = sanitizeHTML(newContentHtml); // Directly set HTML content from AI

                if (highlightChanges) {
                    // Apply highlight to top-level block elements for visual feedback
                    const elements = notepadContent.querySelectorAll('p, li, h1, h2, h3, h4, h5, h6, div, pre, blockquote, table');
                    elements.forEach(el => {
                        // Check if element was likely added/modified (simple check: has content)
                        if (el.textContent.trim().length > 0) {
                            el.classList.add('ai-edit-highlight');
                            // Remove highlight class after animation (matches CSS animation duration)
                            // setTimeout(() => { el.classList.remove('ai-edit-highlight'); }, 3000); // Let CSS handle removal via animation
                        }
                    });
                }

                saveNotepadContent();
                updateNotepadStatus('Updated by AI');

                if (!notepadContainer.classList.contains('visible')) {
                    notepadContainer.classList.add('visible');
                }
            };
        }
        function handleAINotepadEdit(aiMessage) {
            const notepadRegex = /\[NOTEPAD:BEGIN\]([\s\S]*?)\[NOTEPAD:END\]/im; // Case-insensitive, multiline
            const match = aiMessage.match(notepadRegex);

            if (match && match[1]) {
                console.log("Found notepad edit command in AI response.");
                const notepadContentHtml = match[1].trim(); // Assume AI provides HTML or Markdown
                // If AI provides Markdown, parse it here:
                // const parsedHtml = marked.parse(notepadContentHtml);
                // window.updateNotepadFromAI(parsedHtml);
                // For now, assume AI gives usable HTML or plain text formatted correctly
                window.updateNotepadFromAI(notepadContentHtml);

                // Return the message without the notepad markers
                return aiMessage.replace(notepadRegex, '').trim();
            }
            return aiMessage; // Return unchanged
        }


        // --- Core API Interaction (Modified to handle notepad edits) ---
        async function sendMessageToLLM() {
            const messageText = messageInput.value.trim();
            const currentConv = conversations[currentConversationId];
            if (!currentConv) { alert("Error: No active conversation."); return; }
            if (!messageText && !selectedFile) { return; }

            isWaitingForResponse = true; updateButtonStates();
            if (currentAbortController) { currentAbortController.abort(); }
            currentAbortController = new AbortController();

            const userMessageId = generateId();
            let userMessageContent = messageText;

            if (messageText) { addMessage(messageText, 'user-message', { messageId: userMessageId }); currentConv.history.push({ role: 'user', content: messageText, id: userMessageId }); }

            let filePayload = null;
            if (selectedFile) {
                addFilePlaceholderMessage(selectedFile); filePayload = { ...selectedFile };
                if (!currentConv.associatedDocument) { currentConv.associatedDocument = { name: selectedFile.name, type: selectedFile.type, id: generateId() }; if (currentViewMode === 'dashboard') { document.getElementById('documentViewerPlaceholder').innerHTML = `Loading ${selectedFile.name}...`; } }
            }

            messageInput.value = ''; autoResizeTextarea();
            const stagedFile = selectedFile; selectedFile = null;

            const payload = {
                message: userMessageContent, history: currentConv.history.slice(-20), // Increased history slightly
                model: selectedModel, temperature: currentTemperature, responseStyle: currentResponseStyle,
                thinkingMode: isThinkingModeEnabled, webSearch: isWebSearchEnabled,
                enableMedicalTerms: isMedTermEnabled, enableEquipmentAnalysis: isEquipSpecEnabled,
                enableRag: isRagEnabled, knowledgeBaseEndpoint: isRagEnabled ? currentKbEndpoint : null,
                file: stagedFile ? { name: stagedFile.name, type: stagedFile.type, base64: stagedFile.base64, processingOptions: { ocr: currentUploadOptions.ocr, extractTables: currentUploadOptions.tables, segment: currentUploadOptions.segment, workflowId: currentUploadOptions.workflow } } : null,
            };

            removeStreamingIndicator();
            const assistantMessageId = generateId();
            currentStreamingMessageElement = addMessage("", 'assistant', { messageId: assistantMessageId });
            currentStreamingMessageElement.classList.add('streaming');

            let fullResponseText = ""; let receivedCitations = null; let receivedArtifacts = []; let receivedConfidence = null;

            try {
                console.log("Sending payload (structure):", { ...payload, file: payload.file ? {...payload.file, base64: "[omitted]"} : null, history: `[${payload.history?.length || 0} items]` });
                const response = await fetch(API_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal: currentAbortController.signal });
                if (!response.ok) { throw new Error(`API Error (${response.status})`); }

                const reader = response.body.getReader(); const decoder = new TextDecoder(); let buffer = '';
                while (true) {
                    const { value, done } = await reader.read(); if (done) break;
                    buffer += decoder.decode(value, { stream: true }); const lines = buffer.split('\n'); buffer = lines.pop();
                    for (const line of lines) {
                         if (line.trim().startsWith('data:')) {
                             try {
                                 const jsonData = JSON.parse(line.substring(5).trim());
                                 if (jsonData.type === 'chunk' && jsonData.content) { fullResponseText += jsonData.content; currentStreamingMessageElement.innerHTML = marked.parse(fullResponseText); chatContainer.scrollTop = chatContainer.scrollHeight; }
                                 else if (jsonData.type === 'citation') { receivedCitations = jsonData.data; }
                                 else if (jsonData.type === 'artifact') { receivedArtifacts.push(jsonData.data); renderArtifact(jsonData.data); }
                                 else if (jsonData.type === 'confidence') { receivedConfidence = jsonData.score; }
                                 else if (jsonData.type === 'entity') { console.log("Received entity:", jsonData.data); }
                                 else if (jsonData.type === 'done') { console.log("Stream done signal."); }
                             } catch (e) { console.error("Stream parsing error:", e); }
                         }
                    }
                     if (currentStreamingMessageElement && !currentStreamingMessageElement.classList.contains('streaming')) { currentStreamingMessageElement.classList.add('streaming'); }
                } // End while loop

                removeStreamingIndicator();

                // --- Handle Notepad Edit BEFORE saving history/updating final UI ---
                const cleanedResponseText = handleAINotepadEdit(fullResponseText);
                // ---

                // Final message bubble update with cleaned text and citations
                if (currentStreamingMessageElement) {
                    currentStreamingMessageElement.innerHTML = marked.parse(cleanedResponseText); // Use cleaned text
                    if (receivedCitations && receivedCitations.length > 0) {
                        const citationList = document.createElement('div'); citationList.className = 'citation-source-list'; let listHtml = '<h4>Sources:</h4><ul>';
                        receivedCitations.forEach((cite, index) => { const citeNum = index + 1; const regex = new RegExp(`\\\[${citeNum}\\\](?![\w-])`, 'g'); currentStreamingMessageElement.innerHTML = currentStreamingMessageElement.innerHTML.replace(regex, `<span class="citation" title="${cite.title || cite.url}" data-url="${cite.url}">[${citeNum}]</span>`); listHtml += `<li>[${citeNum}] <a href="${cite.url}" target="_blank" rel="noopener noreferrer">${cite.title || cite.url}</a></li>`; });
                        listHtml += '</ul>'; citationList.innerHTML = listHtml; currentStreamingMessageElement.appendChild(citationList);
                    }
                     // Final syntax highlighting run on cleaned content
                     currentStreamingMessageElement.querySelectorAll('pre code').forEach((block) => { hljs.highlightElement(block); const pre = block.parentElement; if (pre && pre.tagName === 'PRE' && !pre.querySelector('.copy-code-btn')) { const copyBtn = document.createElement('button'); copyBtn.className = 'copy-code-btn'; copyBtn.textContent = 'Copy'; copyBtn.onclick = () => copyCodeHandler(block, copyBtn); pre.appendChild(copyBtn); } });
                     // Add confidence score if present
                     if (receivedConfidence !== null) {
                         const confidenceSpan = document.createElement('span'); confidenceSpan.className = 'confidence-score'; confidenceSpan.textContent = `(${(receivedConfidence * 100).toFixed(0)}%)`;
                         let inserted = false; for(let node of currentStreamingMessageElement.childNodes) { if(node.nodeType === Node.TEXT_NODE && node.textContent.trim().length > 0) { node.parentNode.insertBefore(confidenceSpan, node.nextSibling); inserted = true; break; } } if (!inserted) currentStreamingMessageElement.appendChild(confidenceSpan);
                     }
                }

                // Add final assistant response (cleaned) to history
                if (cleanedResponseText || receivedArtifacts.length > 0) {
                    currentConv.history.push({ role: 'assistant', content: cleanedResponseText || "[Generated artifacts]", id: assistantMessageId, citations: receivedCitations, artifacts: receivedArtifacts.map(a => a.id), confidence: receivedConfidence });
                }
                saveConversations();

            } catch (error) { removeStreamingIndicator(); console.error('Error during API call:', error); if (error.name === 'AbortError') { console.log('Fetch aborted'); if (currentStreamingMessageElement && fullResponseText.length < 10) { currentStreamingMessageElement.remove(); } } else { addMessage(`Sorry, error: ${error.message}.`, 'assistant', { messageId: generateId() }); if (currentStreamingMessageElement) currentStreamingMessageElement.remove(); } }
            finally { isWaitingForResponse = false; updateButtonStates(); messageInput.focus(); currentAbortController = null; removeStreamingIndicator(); }
        }


        // --- Event Listeners ---
        viewModeToggle.addEventListener('click', toggleViewMode);
        batchProcessingToggleBtn.addEventListener('click', toggleBatchPanel);
        closeBatchPanelBtn.addEventListener('click', toggleBatchPanel);
        startNewBatchBtn.addEventListener('click', () => { alert("Starting new batch job not implemented."); });
        settingsTabs.forEach(tab => { tab.addEventListener('click', () => switchSettingsTab(tab.dataset.tab)); });
        dataResidency.addEventListener('change', (e) => { currentDataResidency = e.target.value; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].dataResidency = currentDataResidency; saveConversations(); } });
        medTermToggle.addEventListener('change', (e) => { isMedTermEnabled = e.target.checked; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].medTermEnabled = isMedTermEnabled; saveConversations(); } });
        equipSpecToggle.addEventListener('change', (e) => { isEquipSpecEnabled = e.target.checked; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].equipSpecEnabled = isEquipSpecEnabled; saveConversations(); } });
        ragToggle.addEventListener('change', (e) => { isRagEnabled = e.target.checked; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].ragEnabled = isRagEnabled; saveConversations(); } });
        kbEndpoint.addEventListener('change', (e) => { currentKbEndpoint = e.target.value; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].kbEndpoint = currentKbEndpoint; saveConversations(); } });
        enableOcr.addEventListener('change', (e) => currentUploadOptions.ocr = e.target.checked);
        extractTables.addEventListener('change', (e) => currentUploadOptions.tables = e.target.checked);
        segmentDoc.addEventListener('change', (e) => currentUploadOptions.segment = e.target.checked);
        workflowSelect.addEventListener('change', (e) => currentUploadOptions.workflow = e.target.value);
        chatForm.addEventListener('submit', (e) => { e.preventDefault(); if (!sendButton.disabled) { sendMessageToLLM(); } });
        messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); if (!sendButton.disabled) { sendMessageToLLM(); } } if (e.key === '/' && messageInput.value.trim() === '') { renderTemplatesPopup(); templatesPopup.classList.add('active'); } });
        messageInput.addEventListener('input', autoResizeTextarea);
        settingsBtn.addEventListener('click', () => settingsPanel.classList.add('active'));
        closeSettings.addEventListener('click', () => settingsPanel.classList.remove('active'));
        uploadFileBtn.addEventListener('click', () => { resetFileUpload(); fileUploadModal.classList.add('active'); });
        closeFileUploadModal.addEventListener('click', () => fileUploadModal.classList.remove('active'));
        cancelUpload.addEventListener('click', () => { fileUploadModal.classList.remove('active'); resetFileUpload(); });
        dropArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        dropArea.addEventListener('dragover', (e) => { e.preventDefault(); dropArea.classList.add('dragover'); });
        dropArea.addEventListener('dragleave', () => dropArea.classList.remove('dragover'));
        dropArea.addEventListener('drop', (e) => { e.preventDefault(); dropArea.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
        confirmUpload.addEventListener('click', () => { if (selectedFile) { fileUploadModal.classList.remove('active'); sendMessageToLLM(); } }); // Send immediately on confirm
        clearCurrentHistoryBtn.addEventListener('click', () => { if (!currentConversationId || !conversations[currentConversationId]) return; if (confirm(`Clear history for "${conversations[currentConversationId].name}"?`)) { conversations[currentConversationId].history = []; loadConversation(currentConversationId); saveConversations(); settingsPanel.classList.remove('active'); } });
        newChatBtn.addEventListener('click', () => { createNewConversation(); if (sidebar.classList.contains('expanded') && window.innerWidth < 768) { sidebar.classList.remove('expanded'); collapseToggleBtn.innerHTML = '<span>&gt;</span>'; } });
        responseStyleOptions.forEach(radio => { radio.addEventListener('change', function() { if (this.checked) { currentResponseStyle = this.value; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].responseStyle = currentResponseStyle; saveConversations(); } } }); });
        collapseToggleBtn.addEventListener('click', () => { sidebar.classList.toggle('expanded'); collapseToggleBtn.innerHTML = sidebar.classList.contains('expanded') ? '<span>&lt;</span>' : '<span>&gt;</span>'; collapseToggleBtn.title = sidebar.classList.contains('expanded') ? "Collapse Menu" : "Expand Menu"; });
        conversationTitle.addEventListener('click', () => { conversationTitle.style.display = 'none'; conversationTitleInput.style.display = 'inline-block'; conversationTitleInput.focus(); conversationTitleInput.select(); });
        conversationTitleInput.addEventListener('blur', () => { const newName = conversationTitleInput.value.trim(); if (newName && currentConversationId) { renameConversation(currentConversationId, newName); conversationTitle.textContent = newName; } else { conversationTitleInput.value = conversations[currentConversationId]?.name || "Chat"; } conversationTitle.style.display = 'inline-block'; conversationTitleInput.style.display = 'none'; });
        conversationTitleInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); conversationTitleInput.blur(); } else if (e.key === 'Escape') { conversationTitleInput.value = conversations[currentConversationId]?.name || "Chat"; conversationTitleInput.blur(); } });
        modelSelector.addEventListener('change', (e) => { selectedModel = e.target.value; activeModelDisplay.textContent = `Current: ${selectedModel}`; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].model = selectedModel; saveConversations(); } });
        temperatureSlider.addEventListener('input', (e) => { currentTemperature = parseFloat(e.target.value); temperatureValue.textContent = currentTemperature.toFixed(1); });
        temperatureSlider.addEventListener('change', () => { if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].temperature = currentTemperature; saveConversations(); } });
        thinkingModeToggle.addEventListener('change', (e) => { isThinkingModeEnabled = e.target.checked; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].thinkingMode = isThinkingModeEnabled; saveConversations(); } });
        webSearchToggle.addEventListener('change', (e) => { isWebSearchEnabled = e.target.checked; if (currentConversationId && conversations[currentConversationId]) { conversations[currentConversationId].webSearch = isWebSearchEnabled; saveConversations(); } });
        viewEditHistoryBtn.addEventListener('click', showHistoryEditModal);
        closeHistoryModal.addEventListener('click', () => historyEditModal.classList.remove('active'));
        cancelHistoryEdit.addEventListener('click', () => historyEditModal.classList.remove('active'));
        templateBtn.addEventListener('click', (e) => { e.stopPropagation(); renderTemplatesPopup(); templatesPopup.classList.toggle('active'); });
        document.addEventListener('click', (event) => { if (settingsPanel.classList.contains('active') && !settingsPanel.contains(event.target) && !settingsBtn.contains(event.target)) { settingsPanel.classList.remove('active'); } if (templatesPopup.classList.contains('active') && !templatesPopup.contains(event.target) && !templateBtn.contains(event.target)) { templatesPopup.classList.remove('active'); } if (historyEditModal.classList.contains('active') && !historyEditModal.querySelector('.modal-content').contains(event.target)) { historyEditModal.classList.remove('active'); } if (fileUploadModal.classList.contains('active') && !fileUploadModal.querySelector('.modal-content').contains(event.target)) { fileUploadModal.classList.remove('active'); resetFileUpload(); } if (notepadContainer.classList.contains('visible') && !notepadContainer.contains(event.target) && !notepadToggleBtn.contains(event.target)) { /* Don't auto-close notepad on outside click */ } });

        // --- Notepad Event Listeners ---
        notepadToggleBtn.addEventListener('click', () => {
            notepadContainer.classList.toggle('visible');
            if (notepadContainer.classList.contains('visible')) { notepadContent.focus(); }
        });
        notepadCollapseBtn.addEventListener('click', () => { notepadContainer.classList.remove('visible'); });
        notepadClearBtn.addEventListener('click', () => {
            if (notepadContent.textContent.trim() === '') return;
            if (confirm('Clear all notes?')) { notepadContent.innerHTML = ''; saveNotepadContent(); updateNotepadStatus('Cleared'); }
        });
        notepadSaveBtn.addEventListener('click', () => { saveNotepadContent(); updateNotepadStatus('Saved'); });
        notepadAskLLMBtn.addEventListener('click', () => {
            const noteText = notepadContent.textContent; // Get text content for the prompt
            if (!noteText.trim()) { updateNotepadStatus('Nothing to edit'); return; }
            // Simple prompt example - enhance as needed
            const prompt = `Please review, edit for clarity and organization, and potentially summarize the following notes. Format the output using basic HTML (paragraphs, lists, bold). Respond ONLY with the edited notes enclosed in [NOTEPAD:BEGIN] and [NOTEPAD:END] tags.\n\nNotes:\n${noteText}`;
            messageInput.value = prompt;
            updateNotepadStatus('Ready to ask AI'); autoResizeTextarea(); updateButtonStates(); messageInput.focus();
            // notepadContainer.classList.remove('visible'); // Optional: close notepad
        });
        let saveTimeout;
        notepadContent.addEventListener('input', () => {
            updateNotepadStatus('Editing...'); clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => { saveNotepadContent(); updateNotepadStatus('Auto-saved'); }, 1500); // Slightly longer delay
        });
        messageInput.addEventListener('keyup', function(e) {
            if (this.value.trim().startsWith('/note ')) {
                const noteToAdd = this.value.trim().substring(6);
                if (!notepadContainer.classList.contains('visible')) { notepadContainer.classList.add('visible'); }
                const currentContent = notepadContent.innerHTML;
                // Add a line break if needed
                if (currentContent && !currentContent.endsWith('<br>') && !currentContent.endsWith('</p></div>')) { // Check common block element endings
                     notepadContent.innerHTML += '<br>';
                }
                // Append as a simple paragraph (or use a more structured format)
                const p = document.createElement('p');
                p.textContent = noteToAdd; // Use textContent to avoid HTML injection from user input
                notepadContent.appendChild(p);
                // Scroll to bottom of notepad
                notepadContent.scrollTop = notepadContent.scrollHeight;

                saveNotepadContent(); updateNotepadStatus('Note added');
                this.value = ''; autoResizeTextarea(); updateButtonStates();
                e.preventDefault(); // Prevent potential form submission if Enter was used
            }
        });


        // --- Initialization ---
        function initializeApp() {
             console.log("Initializing Enterprise App Concept...");
             loadConversations(); // Includes initial loadConversation call
             updateSettingsUI();
             autoResizeTextarea();
             updateButtonStates();
             messageInput.focus();
             hljs.configure({ ignoreUnescapedHTML: true });
             if (currentViewMode !== 'chat') { toggleViewMode(); }
             initializeNotepad(); // Initialize notepad after conversations are loaded
             updateNotificationCount(3); // Example notification count
             console.log("App Initialized. Current Conv ID:", currentConversationId);
        }
        function updateNotificationCount(count) { if (count > 0) { notificationBadge.textContent = count; notificationBadge.style.display = 'flex'; } else { notificationBadge.style.display = 'none'; } }
        function renderTemplatesPopup() { templatesPopup.innerHTML = ''; const promptTemplates = [ { name: "Summarize Text", prompt: "Please summarize the following text:\n\n" }, { name: "Explain Code", prompt: "Explain this code snippet:\n\n```\n[Your Code Here]\n```\n" }, { name: "Translate to French", prompt: "Translate the following text to French:\n\n" }, { name: "Brainstorm Ideas", prompt: "Brainstorm ideas for:\n\n" }, { name: "Write Email", prompt: "Write a professional email about:\n\nSubject: [Subject]\n\nBody:\n" }, ]; promptTemplates.forEach(template => { const item = document.createElement('div'); item.className = 'template-item'; item.innerHTML = `<strong>${template.name}</strong> ${template.prompt.substring(0, 50)}...`; item.onclick = () => { messageInput.value = template.prompt; templatesPopup.classList.remove('active'); messageInput.focus(); autoResizeTextarea(); }; templatesPopup.appendChild(item); }); }


        // Start the application
        initializeApp();

    </script>
</body>
</html>